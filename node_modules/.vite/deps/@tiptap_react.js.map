{
  "version": 3,
  "sources": ["../../@tiptap/react/src/Context.tsx", "../../@tiptap/react/src/EditorContent.tsx", "../../@tiptap/react/src/useEditor.ts", "../../@tiptap/react/src/useEditorState.ts", "../../@tiptap/react/src/useReactNodeView.ts", "../../@tiptap/react/src/NodeViewContent.tsx", "../../@tiptap/react/src/NodeViewWrapper.tsx", "../../@tiptap/react/src/ReactMarkViewRenderer.tsx", "../../@tiptap/react/src/ReactRenderer.tsx", "../../@tiptap/react/src/ReactNodeViewRenderer.tsx", "../../@tiptap/react/src/Tiptap.tsx", "../../@tiptap/react/src/menus/BubbleMenu.tsx", "../../@tiptap/react/src/menus/FloatingMenu.tsx", "../../@tiptap/react/src/index.ts", "../../src/utils.ts", "../../src/equals.ts", "../../src/comparator.ts", "../../src/index.ts", "../../@floating-ui/utils/dist/floating-ui.utils.mjs", "../../@floating-ui/core/dist/floating-ui.core.mjs", "../../@floating-ui/utils/dist/floating-ui.utils.dom.mjs", "../../@floating-ui/dom/dist/floating-ui.dom.mjs", "../../prosemirror-tables/src/tablemap.ts", "../../prosemirror-tables/src/schema.ts", "../../prosemirror-tables/src/util.ts", "../../prosemirror-tables/src/cellselection.ts", "../../prosemirror-tables/src/fixtables.ts", "../../prosemirror-tables/src/utils/convert.ts", "../../prosemirror-tables/src/utils/move-row-in-array-of-rows.ts", "../../prosemirror-tables/src/utils/query.ts", "../../prosemirror-tables/src/utils/get-cells.ts", "../../prosemirror-tables/src/utils/selection-range.ts", "../../prosemirror-tables/src/utils/transpose.ts", "../../prosemirror-tables/src/utils/move-column.ts", "../../prosemirror-tables/src/utils/move-row.ts", "../../prosemirror-tables/src/commands.ts", "../../prosemirror-tables/src/copypaste.ts", "../../prosemirror-tables/src/input.ts", "../../prosemirror-tables/src/tableview.ts", "../../prosemirror-tables/src/columnresizing.ts", "../../prosemirror-tables/src/index.ts", "../../@tiptap/extension-bubble-menu/src/bubble-menu.ts", "../../@tiptap/extension-bubble-menu/src/bubble-menu-plugin.ts", "../../@tiptap/extension-bubble-menu/src/index.ts", "../../@tiptap/extension-floating-menu/src/floating-menu.ts", "../../@tiptap/extension-floating-menu/src/floating-menu-plugin.ts", "../../@tiptap/extension-floating-menu/src/index.ts"],
  "sourcesContent": ["import type { Editor } from '@tiptap/core'\nimport type { HTMLAttributes, ReactNode } from 'react'\nimport React, { createContext, useContext, useMemo } from 'react'\n\nimport { EditorContent } from './EditorContent.js'\nimport type { UseEditorOptions } from './useEditor.js'\nimport { useEditor } from './useEditor.js'\n\nexport type EditorContextValue = {\n  editor: Editor | null\n}\n\nexport const EditorContext = createContext<EditorContextValue>({\n  editor: null,\n})\n\nexport const EditorConsumer = EditorContext.Consumer\n\n/**\n * A hook to get the current editor instance.\n */\nexport const useCurrentEditor = () => useContext(EditorContext)\n\nexport type EditorProviderProps = {\n  children?: ReactNode\n  slotBefore?: ReactNode\n  slotAfter?: ReactNode\n  editorContainerProps?: HTMLAttributes<HTMLDivElement>\n} & UseEditorOptions\n\n/**\n * This is the provider component for the editor.\n * It allows the editor to be accessible across the entire component tree\n * with `useCurrentEditor`.\n */\nexport function EditorProvider({\n  children,\n  slotAfter,\n  slotBefore,\n  editorContainerProps = {},\n  ...editorOptions\n}: EditorProviderProps) {\n  const editor = useEditor(editorOptions)\n  const contextValue = useMemo(() => ({ editor }), [editor])\n\n  if (!editor) {\n    return null\n  }\n\n  return (\n    <EditorContext.Provider value={contextValue}>\n      {slotBefore}\n      <EditorConsumer>\n        {({ editor: currentEditor }) => <EditorContent editor={currentEditor} {...editorContainerProps} />}\n      </EditorConsumer>\n      {children}\n      {slotAfter}\n    </EditorContext.Provider>\n  )\n}\n", "import type { Editor } from '@tiptap/core'\nimport type { ForwardedRef, HTMLProps, LegacyRef, MutableRefObject } from 'react'\nimport React, { forwardRef } from 'react'\nimport ReactDOM from 'react-dom'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js'\n\nimport type { ContentComponent, EditorWithContentComponent } from './Editor.js'\nimport type { ReactRenderer } from './ReactRenderer.js'\n\nconst mergeRefs = <T extends HTMLDivElement>(...refs: Array<MutableRefObject<T> | LegacyRef<T> | undefined>) => {\n  return (node: T) => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node)\n      } else if (ref) {\n        ;(ref as MutableRefObject<T | null>).current = node\n      }\n    })\n  }\n}\n\n/**\n * This component renders all of the editor's node views.\n */\nconst Portals: React.FC<{ contentComponent: ContentComponent }> = ({ contentComponent }) => {\n  // For performance reasons, we render the node view portals on state changes only\n  const renderers = useSyncExternalStore(\n    contentComponent.subscribe,\n    contentComponent.getSnapshot,\n    contentComponent.getServerSnapshot,\n  )\n\n  // This allows us to directly render the portals without any additional wrapper\n  return <>{Object.values(renderers)}</>\n}\n\nexport interface EditorContentProps extends HTMLProps<HTMLDivElement> {\n  editor: Editor | null\n  innerRef?: ForwardedRef<HTMLDivElement | null>\n}\n\nfunction getInstance(): ContentComponent {\n  const subscribers = new Set<() => void>()\n  let renderers: Record<string, React.ReactPortal> = {}\n\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback: () => void) {\n      subscribers.add(callback)\n      return () => {\n        subscribers.delete(callback)\n      }\n    },\n    getSnapshot() {\n      return renderers\n    },\n    getServerSnapshot() {\n      return renderers\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(id: string, renderer: ReactRenderer) {\n      renderers = {\n        ...renderers,\n        [id]: ReactDOM.createPortal(renderer.reactElement, renderer.element, id),\n      }\n\n      subscribers.forEach(subscriber => subscriber())\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(id: string) {\n      const nextRenderers = { ...renderers }\n\n      delete nextRenderers[id]\n      renderers = nextRenderers\n      subscribers.forEach(subscriber => subscriber())\n    },\n  }\n}\n\nexport class PureEditorContent extends React.Component<\n  EditorContentProps,\n  { hasContentComponentInitialized: boolean }\n> {\n  editorContentRef: React.RefObject<any>\n\n  initialized: boolean\n\n  unsubscribeToContentComponent?: () => void\n\n  constructor(props: EditorContentProps) {\n    super(props)\n    this.editorContentRef = React.createRef()\n    this.initialized = false\n\n    this.state = {\n      hasContentComponentInitialized: Boolean((props.editor as EditorWithContentComponent | null)?.contentComponent),\n    }\n  }\n\n  componentDidMount() {\n    this.init()\n  }\n\n  componentDidUpdate() {\n    this.init()\n  }\n\n  init() {\n    const editor = this.props.editor as EditorWithContentComponent | null\n\n    if (editor && !editor.isDestroyed && editor.view.dom?.parentNode) {\n      if (editor.contentComponent) {\n        return\n      }\n\n      const element = this.editorContentRef.current\n\n      element.append(...editor.view.dom.parentNode.childNodes)\n\n      editor.setOptions({\n        element,\n      })\n\n      editor.contentComponent = getInstance()\n\n      // Has the content component been initialized?\n      if (!this.state.hasContentComponentInitialized) {\n        // Subscribe to the content component\n        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n          this.setState(prevState => {\n            if (!prevState.hasContentComponentInitialized) {\n              return {\n                hasContentComponentInitialized: true,\n              }\n            }\n            return prevState\n          })\n\n          // Unsubscribe to previous content component\n          if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent()\n          }\n        })\n      }\n\n      editor.createNodeViews()\n\n      this.initialized = true\n    }\n  }\n\n  componentWillUnmount() {\n    const editor = this.props.editor as EditorWithContentComponent | null\n\n    if (!editor) {\n      return\n    }\n\n    this.initialized = false\n\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {},\n      })\n    }\n\n    if (this.unsubscribeToContentComponent) {\n      this.unsubscribeToContentComponent()\n    }\n\n    editor.contentComponent = null\n\n    // try to reset the editor element\n    // may fail if this editor's view.dom was never initialized/mounted yet\n    try {\n      if (!editor.view.dom?.parentNode) {\n        return\n      }\n\n      // TODO using the new editor.mount method might allow us to remove this\n      const newElement = document.createElement('div')\n\n      newElement.append(...editor.view.dom.parentNode.childNodes)\n\n      editor.setOptions({\n        element: newElement,\n      })\n    } catch {\n      // do nothing, nothing to reset\n    }\n  }\n\n  render() {\n    const { editor, innerRef, ...rest } = this.props\n\n    return (\n      <>\n        <div ref={mergeRefs(innerRef, this.editorContentRef)} {...rest} />\n        {/* @ts-ignore */}\n        {editor?.contentComponent && <Portals contentComponent={editor.contentComponent} />}\n      </>\n    )\n  }\n}\n\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = forwardRef<HTMLDivElement, EditorContentProps>(\n  (props: Omit<EditorContentProps, 'innerRef'>, ref) => {\n    const key = React.useMemo(() => {\n      return Math.floor(Math.random() * 0xffffffff).toString()\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [props.editor])\n\n    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n    return React.createElement(PureEditorContent, {\n      key,\n      innerRef: ref,\n      ...props,\n    })\n  },\n)\n\nexport const EditorContent = React.memo(EditorContentWithKey)\n", "import { type EditorOptions, Editor } from '@tiptap/core'\nimport type { DependencyList, MutableRefObject } from 'react'\nimport { useDebugValue, useEffect, useRef, useState } from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js'\n\nimport { useEditorState } from './useEditorState.js'\n\n// @ts-ignore\nconst isDev = process.env.NODE_ENV !== 'production'\nconst isSSR = typeof window === 'undefined'\nconst isNext = isSSR || Boolean(typeof window !== 'undefined' && (window as any).next)\n\n/**\n * The options for the `useEditor` hook.\n */\nexport type UseEditorOptions = Partial<EditorOptions> & {\n  /**\n   * Whether to render the editor on the first render.\n   * If client-side rendering, set this to `true`.\n   * If server-side rendering, set this to `false`.\n   * @default true\n   */\n  immediatelyRender?: boolean\n  /**\n   * Whether to re-render the editor on each transaction.\n   * This is legacy behavior that will be removed in future versions.\n   * @default false\n   */\n  shouldRerenderOnTransaction?: boolean\n}\n\n/**\n * This class handles the creation, destruction, and re-creation of the editor instance.\n */\nclass EditorInstanceManager {\n  /**\n   * The current editor instance.\n   */\n  private editor: Editor | null = null\n\n  /**\n   * The most recent options to apply to the editor.\n   */\n  private options: MutableRefObject<UseEditorOptions>\n\n  /**\n   * The subscriptions to notify when the editor instance\n   * has been created or destroyed.\n   */\n  private subscriptions = new Set<() => void>()\n\n  /**\n   * A timeout to destroy the editor if it was not mounted within a time frame.\n   */\n  private scheduledDestructionTimeout: ReturnType<typeof setTimeout> | undefined\n\n  /**\n   * Whether the editor has been mounted.\n   */\n  private isComponentMounted = false\n\n  /**\n   * The most recent dependencies array.\n   */\n  private previousDeps: DependencyList | null = null\n\n  /**\n   * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n   */\n  public instanceId = ''\n\n  constructor(options: MutableRefObject<UseEditorOptions>) {\n    this.options = options\n    this.subscriptions = new Set<() => void>()\n    this.setEditor(this.getInitialEditor())\n    this.scheduleDestroy()\n\n    this.getEditor = this.getEditor.bind(this)\n    this.getServerSnapshot = this.getServerSnapshot.bind(this)\n    this.subscribe = this.subscribe.bind(this)\n    this.refreshEditorInstance = this.refreshEditorInstance.bind(this)\n    this.scheduleDestroy = this.scheduleDestroy.bind(this)\n    this.onRender = this.onRender.bind(this)\n    this.createEditor = this.createEditor.bind(this)\n  }\n\n  private setEditor(editor: Editor | null) {\n    this.editor = editor\n    this.instanceId = Math.random().toString(36).slice(2, 9)\n\n    // Notify all subscribers that the editor instance has been created\n    this.subscriptions.forEach(cb => cb())\n  }\n\n  private getInitialEditor() {\n    if (this.options.current.immediatelyRender === undefined) {\n      if (isSSR || isNext) {\n        if (isDev) {\n          /**\n           * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd\n           * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.\n           */\n          throw new Error(\n            'Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.',\n          )\n        }\n\n        // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production\n        return null\n      }\n\n      // Default to immediately rendering when client-side rendering\n      return this.createEditor()\n    }\n\n    if (this.options.current.immediatelyRender && isSSR && isDev) {\n      // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.\n      throw new Error(\n        'Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.',\n      )\n    }\n\n    if (this.options.current.immediatelyRender) {\n      return this.createEditor()\n    }\n\n    return null\n  }\n\n  /**\n   * Create a new editor instance. And attach event listeners.\n   */\n  private createEditor(): Editor {\n    const optionsToApply: Partial<EditorOptions> = {\n      ...this.options.current,\n      // Always call the most recent version of the callback function by default\n      onBeforeCreate: (...args) => this.options.current.onBeforeCreate?.(...args),\n      onBlur: (...args) => this.options.current.onBlur?.(...args),\n      onCreate: (...args) => this.options.current.onCreate?.(...args),\n      onDestroy: (...args) => this.options.current.onDestroy?.(...args),\n      onFocus: (...args) => this.options.current.onFocus?.(...args),\n      onSelectionUpdate: (...args) => this.options.current.onSelectionUpdate?.(...args),\n      onTransaction: (...args) => this.options.current.onTransaction?.(...args),\n      onUpdate: (...args) => this.options.current.onUpdate?.(...args),\n      onContentError: (...args) => this.options.current.onContentError?.(...args),\n      onDrop: (...args) => this.options.current.onDrop?.(...args),\n      onPaste: (...args) => this.options.current.onPaste?.(...args),\n      onDelete: (...args) => this.options.current.onDelete?.(...args),\n    }\n    const editor = new Editor(optionsToApply)\n\n    // no need to keep track of the event listeners, they will be removed when the editor is destroyed\n\n    return editor\n  }\n\n  /**\n   * Get the current editor instance.\n   */\n  getEditor(): Editor | null {\n    return this.editor\n  }\n\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot(): null {\n    return null\n  }\n\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(onStoreChange: () => void) {\n    this.subscriptions.add(onStoreChange)\n\n    return () => {\n      this.subscriptions.delete(onStoreChange)\n    }\n  }\n\n  static compareOptions(a: UseEditorOptions, b: UseEditorOptions) {\n    return (Object.keys(a) as (keyof UseEditorOptions)[]).every(key => {\n      if (\n        [\n          'onCreate',\n          'onBeforeCreate',\n          'onDestroy',\n          'onUpdate',\n          'onTransaction',\n          'onFocus',\n          'onBlur',\n          'onSelectionUpdate',\n          'onContentError',\n          'onDrop',\n          'onPaste',\n        ].includes(key)\n      ) {\n        // we don't want to compare callbacks, they are always different and only registered once\n        return true\n      }\n\n      // We often encourage putting extensions inlined in the options object, so we will do a slightly deeper comparison here\n      if (key === 'extensions' && a.extensions && b.extensions) {\n        if (a.extensions.length !== b.extensions.length) {\n          return false\n        }\n        return a.extensions.every((extension, index) => {\n          if (extension !== b.extensions?.[index]) {\n            return false\n          }\n          return true\n        })\n      }\n      if (a[key] !== b[key]) {\n        // if any of the options have changed, we should update the editor options\n        return false\n      }\n      return true\n    })\n  }\n\n  /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */\n  onRender(deps: DependencyList) {\n    // The returned callback will run on each render\n    return () => {\n      this.isComponentMounted = true\n      // Cleanup any scheduled destructions, since we are currently rendering\n      clearTimeout(this.scheduledDestructionTimeout)\n\n      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n        // if the editor does exist & deps are empty, we don't need to re-initialize the editor generally\n        if (!EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n          // But, the options are different, so we need to update the editor options\n          // Still, this is faster than re-creating the editor\n          this.editor.setOptions({\n            ...this.options.current,\n            editable: this.editor.isEditable,\n          })\n        }\n      } else {\n        // When the editor:\n        // - does not yet exist\n        // - is destroyed\n        // - the deps array changes\n        // We need to destroy the editor instance and re-initialize it\n        this.refreshEditorInstance(deps)\n      }\n\n      return () => {\n        this.isComponentMounted = false\n        this.scheduleDestroy()\n      }\n    }\n  }\n\n  /**\n   * Recreate the editor instance if the dependencies have changed.\n   */\n  private refreshEditorInstance(deps: DependencyList) {\n    if (this.editor && !this.editor.isDestroyed) {\n      // Editor instance already exists\n      if (this.previousDeps === null) {\n        // If lastDeps has not yet been initialized, reuse the current editor instance\n        this.previousDeps = deps\n        return\n      }\n      const depsAreEqual =\n        this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index])\n\n      if (depsAreEqual) {\n        // deps exist and are equal, no need to recreate\n        return\n      }\n    }\n\n    if (this.editor && !this.editor.isDestroyed) {\n      // Destroy the editor instance if it exists\n      this.editor.destroy()\n    }\n\n    this.setEditor(this.createEditor())\n\n    // Update the lastDeps to the current deps\n    this.previousDeps = deps\n  }\n\n  /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */\n  private scheduleDestroy() {\n    const currentInstanceId = this.instanceId\n    const currentEditor = this.editor\n\n    // Wait two ticks to see if the component is still mounted\n    this.scheduledDestructionTimeout = setTimeout(() => {\n      if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n        // If still mounted on the following tick, with the same instanceId, do not destroy the editor\n        if (currentEditor) {\n          // just re-apply options as they might have changed\n          currentEditor.setOptions(this.options.current)\n        }\n        return\n      }\n      if (currentEditor && !currentEditor.isDestroyed) {\n        currentEditor.destroy()\n        if (this.instanceId === currentInstanceId) {\n          this.setEditor(null)\n        }\n      }\n      // This allows the effect to run again between ticks\n      // which may save us from having to re-create the editor\n    }, 1)\n  }\n}\n\n/**\n * This hook allows you to create an editor instance.\n * @param options The editor options\n * @param deps The dependencies to watch for changes\n * @returns The editor instance\n * @example const editor = useEditor({ extensions: [...] })\n */\nexport function useEditor(\n  options: UseEditorOptions & { immediatelyRender: false },\n  deps?: DependencyList,\n): Editor | null\n\n/**\n * This hook allows you to create an editor instance.\n * @param options The editor options\n * @param deps The dependencies to watch for changes\n * @returns The editor instance\n * @example const editor = useEditor({ extensions: [...] })\n */\nexport function useEditor(options: UseEditorOptions, deps?: DependencyList): Editor\n\nexport function useEditor(options: UseEditorOptions = {}, deps: DependencyList = []): Editor | null {\n  const mostRecentOptions = useRef(options)\n\n  mostRecentOptions.current = options\n\n  const [instanceManager] = useState(() => new EditorInstanceManager(mostRecentOptions))\n\n  const editor = useSyncExternalStore(\n    instanceManager.subscribe,\n    instanceManager.getEditor,\n    instanceManager.getServerSnapshot,\n  )\n\n  useDebugValue(editor)\n\n  // This effect will handle creating/updating the editor instance\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(instanceManager.onRender(deps))\n\n  // The default behavior is to re-render on each transaction\n  // This is legacy behavior that will be removed in future versions\n  useEditorState({\n    editor,\n    selector: ({ transactionNumber }) => {\n      if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === undefined) {\n        // This will prevent the editor from re-rendering on each transaction\n        return null\n      }\n\n      // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`\n      if (options.immediatelyRender && transactionNumber === 0) {\n        return 0\n      }\n      return transactionNumber + 1\n    },\n  })\n\n  return editor\n}\n", "import type { Editor } from '@tiptap/core'\nimport { deepEqual } from 'fast-equals'\nimport { useDebugValue, useEffect, useLayoutEffect, useState } from 'react'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n\nexport type EditorStateSnapshot<TEditor extends Editor | null = Editor | null> = {\n  editor: TEditor\n  transactionNumber: number\n}\n\nexport type UseEditorStateOptions<TSelectorResult, TEditor extends Editor | null = Editor | null> = {\n  /**\n   * The editor instance.\n   */\n  editor: TEditor\n  /**\n   * A selector function to determine the value to compare for re-rendering.\n   */\n  selector: (context: EditorStateSnapshot<TEditor>) => TSelectorResult\n  /**\n   * A custom equality function to determine if the editor should re-render.\n   * @default `deepEqual` from `fast-deep-equal`\n   */\n  equalityFn?: (a: TSelectorResult, b: TSelectorResult | null) => boolean\n}\n\n/**\n * To synchronize the editor instance with the component state,\n * we need to create a separate instance that is not affected by the component re-renders.\n */\nclass EditorStateManager<TEditor extends Editor | null = Editor | null> {\n  private transactionNumber = 0\n\n  private lastTransactionNumber = 0\n\n  private lastSnapshot: EditorStateSnapshot<TEditor>\n\n  private editor: TEditor\n\n  private subscribers = new Set<() => void>()\n\n  constructor(initialEditor: TEditor) {\n    this.editor = initialEditor\n    this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 }\n\n    this.getSnapshot = this.getSnapshot.bind(this)\n    this.getServerSnapshot = this.getServerSnapshot.bind(this)\n    this.watch = this.watch.bind(this)\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  /**\n   * Get the current editor instance.\n   */\n  getSnapshot(): EditorStateSnapshot<TEditor> {\n    if (this.transactionNumber === this.lastTransactionNumber) {\n      return this.lastSnapshot\n    }\n    this.lastTransactionNumber = this.transactionNumber\n    this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }\n    return this.lastSnapshot\n  }\n\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot(): EditorStateSnapshot<null> {\n    return { editor: null, transactionNumber: 0 }\n  }\n\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(callback: () => void): () => void {\n    this.subscribers.add(callback)\n    return () => {\n      this.subscribers.delete(callback)\n    }\n  }\n\n  /**\n   * Watch the editor instance for changes.\n   */\n  watch(nextEditor: Editor | null): undefined | (() => void) {\n    this.editor = nextEditor as TEditor\n\n    if (this.editor) {\n      /**\n       * This will force a re-render when the editor state changes.\n       * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.\n       * This could be more efficient, but it's a good trade-off for now.\n       */\n      const fn = () => {\n        this.transactionNumber += 1\n        this.subscribers.forEach(callback => callback())\n      }\n\n      const currentEditor = this.editor\n\n      currentEditor.on('transaction', fn)\n      return () => {\n        currentEditor.off('transaction', fn)\n      }\n    }\n\n    return undefined\n  }\n}\n\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor>,\n): TSelectorResult\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor | null>,\n): TSelectorResult | null\n\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor> | UseEditorStateOptions<TSelectorResult, Editor | null>,\n): TSelectorResult | null {\n  const [editorStateManager] = useState(() => new EditorStateManager(options.editor))\n\n  // Using the `useSyncExternalStore` hook to sync the editor instance with the component state\n  const selectedState = useSyncExternalStoreWithSelector(\n    editorStateManager.subscribe,\n    editorStateManager.getSnapshot,\n    editorStateManager.getServerSnapshot,\n    options.selector as UseEditorStateOptions<TSelectorResult, Editor | null>['selector'],\n    options.equalityFn ?? deepEqual,\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    return editorStateManager.watch(options.editor)\n  }, [options.editor, editorStateManager])\n\n  useDebugValue(selectedState)\n\n  return selectedState\n}\n", "import type { ReactNode } from 'react'\nimport { createContext, createElement, useContext } from 'react'\n\nexport interface ReactNodeViewContextProps {\n  onDragStart?: (event: DragEvent) => void\n  nodeViewContentRef?: (element: HTMLElement | null) => void\n  /**\n   * This allows you to add children into the NodeViewContent component.\n   * This is useful when statically rendering the content of a node view.\n   */\n  nodeViewContentChildren?: ReactNode\n}\n\nexport const ReactNodeViewContext = createContext<ReactNodeViewContextProps>({\n  onDragStart: () => {\n    // no-op\n  },\n  nodeViewContentChildren: undefined,\n  nodeViewContentRef: () => {\n    // no-op\n  },\n})\n\nexport const ReactNodeViewContentProvider = ({ children, content }: { children: ReactNode; content: ReactNode }) => {\n  return createElement(ReactNodeViewContext.Provider, { value: { nodeViewContentChildren: content } }, children)\n}\n\nexport const useReactNodeView = () => useContext(ReactNodeViewContext)\n", "import type { ComponentProps } from 'react'\nimport React from 'react'\n\nimport { useReactNodeView } from './useReactNodeView.js'\n\nexport type NodeViewContentProps<T extends keyof React.JSX.IntrinsicElements = 'div'> = {\n  as?: NoInfer<T>\n} & ComponentProps<T>\n\nexport function NodeViewContent<T extends keyof React.JSX.IntrinsicElements = 'div'>({\n  as: Tag = 'div' as T,\n  ...props\n}: NodeViewContentProps<T>) {\n  const { nodeViewContentRef, nodeViewContentChildren } = useReactNodeView()\n\n  return (\n    // @ts-ignore\n    <Tag\n      {...props}\n      ref={nodeViewContentRef}\n      data-node-view-content=\"\"\n      style={{\n        whiteSpace: 'pre-wrap',\n        ...props.style,\n      }}\n    >\n      {nodeViewContentChildren}\n    </Tag>\n  )\n}\n", "import React from 'react'\n\nimport { useReactNodeView } from './useReactNodeView.js'\n\nexport interface NodeViewWrapperProps {\n  [key: string]: any\n  as?: React.ElementType\n}\n\nexport const NodeViewWrapper: React.FC<NodeViewWrapperProps> = React.forwardRef((props, ref) => {\n  const { onDragStart } = useReactNodeView()\n  const Tag = props.as || 'div'\n\n  return (\n    // @ts-ignore\n    <Tag\n      {...props}\n      ref={ref}\n      data-node-view-wrapper=\"\"\n      onDragStart={onDragStart}\n      style={{\n        whiteSpace: 'normal',\n        ...props.style,\n      }}\n    />\n  )\n})\n", "/* eslint-disable @typescript-eslint/no-shadow */\nimport type { MarkViewProps, MarkViewRenderer, MarkViewRendererOptions } from '@tiptap/core'\nimport { MarkView } from '@tiptap/core'\nimport React from 'react'\n\n// import { flushSync } from 'react-dom'\nimport { ReactRenderer } from './ReactRenderer.js'\n\nexport interface MarkViewContextProps {\n  markViewContentRef: (element: HTMLElement | null) => void\n}\nexport const ReactMarkViewContext = React.createContext<MarkViewContextProps>({\n  markViewContentRef: () => {\n    // do nothing\n  },\n})\n\nexport type MarkViewContentProps<T extends keyof React.JSX.IntrinsicElements = 'span'> = {\n  as?: T\n} & Omit<React.ComponentProps<T>, 'as'>\n\nexport const MarkViewContent = <T extends keyof React.JSX.IntrinsicElements = 'span'>(\n  props: MarkViewContentProps<T>,\n) => {\n  const { as: Tag = 'span', ...rest } = props\n  const { markViewContentRef } = React.useContext(ReactMarkViewContext)\n\n  return (\n    // @ts-ignore\n    <Tag {...rest} ref={markViewContentRef} data-mark-view-content=\"\" />\n  )\n}\n\nexport interface ReactMarkViewRendererOptions extends MarkViewRendererOptions {\n  /**\n   * The tag name of the element wrapping the React component.\n   */\n  as?: string\n  className?: string\n  attrs?: { [key: string]: string }\n}\n\nexport class ReactMarkView extends MarkView<React.ComponentType<MarkViewProps>, ReactMarkViewRendererOptions> {\n  renderer: ReactRenderer\n  contentDOMElement: HTMLElement\n\n  constructor(\n    component: React.ComponentType<MarkViewProps>,\n    props: MarkViewProps,\n    options?: Partial<ReactMarkViewRendererOptions>,\n  ) {\n    super(component, props, options)\n\n    const { as = 'span', attrs, className = '' } = options || {}\n    const componentProps = { ...props, updateAttributes: this.updateAttributes.bind(this) } satisfies MarkViewProps\n\n    this.contentDOMElement = document.createElement('span')\n\n    const markViewContentRef: MarkViewContextProps['markViewContentRef'] = el => {\n      if (el && !el.contains(this.contentDOMElement)) {\n        el.appendChild(this.contentDOMElement)\n      }\n    }\n    const context: MarkViewContextProps = {\n      markViewContentRef,\n    }\n\n    // For performance reasons, we memoize the provider component\n    // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n    const ReactMarkViewProvider: React.FunctionComponent<MarkViewProps> = React.memo(componentProps => {\n      return (\n        <ReactMarkViewContext.Provider value={context}>\n          {React.createElement(component, componentProps)}\n        </ReactMarkViewContext.Provider>\n      )\n    })\n\n    ReactMarkViewProvider.displayName = 'ReactMarkView'\n\n    this.renderer = new ReactRenderer(ReactMarkViewProvider, {\n      editor: props.editor,\n      props: componentProps,\n      as,\n      className: `mark-${props.mark.type.name} ${className}`.trim(),\n    })\n\n    if (attrs) {\n      this.renderer.updateAttributes(attrs)\n    }\n  }\n\n  get dom() {\n    return this.renderer.element\n  }\n\n  get contentDOM() {\n    return this.contentDOMElement\n  }\n}\n\nexport function ReactMarkViewRenderer(\n  component: React.ComponentType<MarkViewProps>,\n  options: Partial<ReactMarkViewRendererOptions> = {},\n): MarkViewRenderer {\n  return props => new ReactMarkView(component, props, options)\n}\n", "import type { Editor } from '@tiptap/core'\nimport type {\n  ComponentClass,\n  ForwardRefExoticComponent,\n  FunctionComponent,\n  PropsWithoutRef,\n  ReactNode,\n  RefAttributes,\n} from 'react'\nimport { version as reactVersion } from 'react'\nimport { flushSync } from 'react-dom'\n\nimport type { EditorWithContentComponent } from './Editor.js'\n\n/**\n * Check if a component is a class component.\n * @param Component\n * @returns {boolean}\n */\nfunction isClassComponent(Component: any) {\n  return !!(typeof Component === 'function' && Component.prototype && Component.prototype.isReactComponent)\n}\n\n/**\n * Check if a component is a forward ref component.\n * @param Component\n * @returns {boolean}\n */\nfunction isForwardRefComponent(Component: any) {\n  return !!(\n    typeof Component === 'object' &&\n    Component.$$typeof &&\n    (Component.$$typeof.toString() === 'Symbol(react.forward_ref)' ||\n      Component.$$typeof.description === 'react.forward_ref')\n  )\n}\n\n/**\n * Check if a component is a memoized component.\n * @param Component\n * @returns {boolean}\n */\nfunction isMemoComponent(Component: any) {\n  return !!(\n    typeof Component === 'object' &&\n    Component.$$typeof &&\n    (Component.$$typeof.toString() === 'Symbol(react.memo)' || Component.$$typeof.description === 'react.memo')\n  )\n}\n\n/**\n * Check if a component can safely receive a ref prop.\n * This includes class components, forwardRef components, and memoized components\n * that wrap forwardRef or class components.\n * @param Component\n * @returns {boolean}\n */\nfunction canReceiveRef(Component: any) {\n  // Check if it's a class component\n  if (isClassComponent(Component)) {\n    return true\n  }\n\n  // Check if it's a forwardRef component\n  if (isForwardRefComponent(Component)) {\n    return true\n  }\n\n  // Check if it's a memoized component\n  if (isMemoComponent(Component)) {\n    // For memoized components, check the wrapped component\n    const wrappedComponent = Component.type\n    if (wrappedComponent) {\n      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent)\n    }\n  }\n\n  return false\n}\n\n/**\n * Check if we're running React 19+ by detecting if function components support ref props\n * @returns {boolean}\n */\nfunction isReact19Plus(): boolean {\n  // React 19 is detected by checking React version if available\n  // In practice, we'll use a more conservative approach and assume React 18 behavior\n  // unless we can definitively detect React 19\n  try {\n    // @ts-ignore\n    if (reactVersion) {\n      const majorVersion = parseInt(reactVersion.split('.')[0], 10)\n      return majorVersion >= 19\n    }\n  } catch {\n    // Fallback to React 18 behavior if we can't determine version\n  }\n  return false\n}\n\nexport interface ReactRendererOptions {\n  /**\n   * The editor instance.\n   * @type {Editor}\n   */\n  editor: Editor\n\n  /**\n   * The props for the component.\n   * @type {Record<string, any>}\n   * @default {}\n   */\n  props?: Record<string, any>\n\n  /**\n   * The tag name of the element.\n   * @type {string}\n   * @default 'div'\n   */\n  as?: string\n\n  /**\n   * The class name of the element.\n   * @type {string}\n   * @default ''\n   * @example 'foo bar'\n   */\n  className?: string\n}\n\ntype ComponentType<R, P> =\n  | ComponentClass<P>\n  | FunctionComponent<P>\n  | ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<R>>\n\n/**\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\n * @example\n * new ReactRenderer(MyComponent, {\n *   editor,\n *   props: {\n *     foo: 'bar',\n *   },\n *   as: 'span',\n * })\n */\nexport class ReactRenderer<R = unknown, P extends Record<string, any> = object> {\n  id: string\n\n  editor: Editor\n\n  component: any\n\n  element: HTMLElement\n\n  props: P\n\n  reactElement: ReactNode\n\n  ref: R | null = null\n\n  /**\n   * Flag to track if the renderer has been destroyed, preventing queued or asynchronous renders from executing after teardown.\n   */\n  destroyed = false\n\n  /**\n   * Immediately creates element and renders the provided React component.\n   */\n  constructor(\n    component: ComponentType<R, P>,\n    { editor, props = {}, as = 'div', className = '' }: ReactRendererOptions,\n  ) {\n    this.id = Math.floor(Math.random() * 0xffffffff).toString()\n    this.component = component\n    this.editor = editor as EditorWithContentComponent\n    this.props = props as P\n    this.element = document.createElement(as)\n    this.element.classList.add('react-renderer')\n\n    if (className) {\n      this.element.classList.add(...className.split(' '))\n    }\n\n    // If the editor is already initialized, we will need to\n    // synchronously render the component to ensure it renders\n    // together with Prosemirror's rendering.\n    if (this.editor.isInitialized) {\n      flushSync(() => {\n        this.render()\n      })\n    } else {\n      queueMicrotask(() => {\n        if (this.destroyed) {\n          return\n        }\n        this.render()\n      })\n    }\n  }\n\n  /**\n   * Render the React component.\n   */\n  render(): void {\n    if (this.destroyed) {\n      return\n    }\n\n    const Component = this.component\n    const props = this.props\n    const editor = this.editor as EditorWithContentComponent\n\n    // Handle ref forwarding with React 18/19 compatibility\n    const isReact19 = isReact19Plus()\n    const componentCanReceiveRef = canReceiveRef(Component)\n\n    const elementProps = { ...props }\n\n    // Always remove ref if the component cannot receive it (unless React 19+)\n    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n      delete elementProps.ref\n    }\n\n    // Only assign our own ref if allowed\n    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n      // @ts-ignore - Setting ref prop for compatible components\n      elementProps.ref = (ref: R) => {\n        this.ref = ref\n      }\n    }\n\n    this.reactElement = <Component {...elementProps} />\n\n    editor?.contentComponent?.setRenderer(this.id, this)\n  }\n\n  /**\n   * Re-renders the React component with new props.\n   */\n  updateProps(props: Record<string, any> = {}): void {\n    if (this.destroyed) {\n      return\n    }\n\n    this.props = {\n      ...this.props,\n      ...props,\n    }\n\n    this.render()\n  }\n\n  /**\n   * Destroy the React component.\n   */\n  destroy(): void {\n    this.destroyed = true\n    const editor = this.editor as EditorWithContentComponent\n\n    editor?.contentComponent?.removeRenderer(this.id)\n    // If the consumer appended the element to the document (for example\n    // many demos append the renderer element to document.body), make sure\n    // we remove it here to avoid leaking DOM nodes / React roots.\n    try {\n      if (this.element && this.element.parentNode) {\n        this.element.parentNode.removeChild(this.element)\n      }\n    } catch {\n      // ignore DOM removal errors\n    }\n  }\n\n  /**\n   * Update the attributes of the element that holds the React component.\n   */\n  updateAttributes(attributes: Record<string, string>): void {\n    Object.keys(attributes).forEach(key => {\n      this.element.setAttribute(key, attributes[key])\n    })\n  }\n}\n", "import type {\n  DecorationWithType,\n  Editor,\n  NodeViewRenderer,\n  NodeViewRendererOptions,\n  NodeViewRendererProps,\n} from '@tiptap/core'\nimport { getRenderedAttributes, NodeView } from '@tiptap/core'\nimport type { Node, Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport type { Decoration, DecorationSource, NodeView as ProseMirrorNodeView } from '@tiptap/pm/view'\nimport type { ComponentType, NamedExoticComponent } from 'react'\nimport { createElement, createRef, memo } from 'react'\n\nimport type { EditorWithContentComponent } from './Editor.js'\nimport { ReactRenderer } from './ReactRenderer.js'\nimport type { ReactNodeViewProps } from './types.js'\nimport type { ReactNodeViewContextProps } from './useReactNodeView.js'\nimport { ReactNodeViewContext } from './useReactNodeView.js'\n\nexport interface ReactNodeViewRendererOptions extends NodeViewRendererOptions {\n  /**\n   * This function is called when the node view is updated.\n   * It allows you to compare the old node with the new node and decide if the component should update.\n   */\n  update:\n    | ((props: {\n        oldNode: ProseMirrorNode\n        oldDecorations: readonly Decoration[]\n        oldInnerDecorations: DecorationSource\n        newNode: ProseMirrorNode\n        newDecorations: readonly Decoration[]\n        innerDecorations: DecorationSource\n        updateProps: () => void\n      }) => boolean)\n    | null\n  /**\n   * The tag name of the element wrapping the React component.\n   */\n  as?: string\n  /**\n   * The class name of the element wrapping the React component.\n   */\n  className?: string\n  /**\n   * Attributes that should be applied to the element wrapping the React component.\n   * If this is a function, it will be called each time the node view is updated.\n   * If this is an object, it will be applied once when the node view is mounted.\n   */\n  attrs?:\n    | Record<string, string>\n    | ((props: { node: ProseMirrorNode; HTMLAttributes: Record<string, any> }) => Record<string, string>)\n}\n\nexport class ReactNodeView<\n  T = HTMLElement,\n  Component extends ComponentType<ReactNodeViewProps<T>> = ComponentType<ReactNodeViewProps<T>>,\n  NodeEditor extends Editor = Editor,\n  Options extends ReactNodeViewRendererOptions = ReactNodeViewRendererOptions,\n> extends NodeView<Component, NodeEditor, Options> {\n  /**\n   * The renderer instance.\n   */\n  renderer!: ReactRenderer<unknown, ReactNodeViewProps<T>>\n\n  /**\n   * The element that holds the rich-text content of the node.\n   */\n  contentDOMElement!: HTMLElement | null\n\n  /**\n   * The requestAnimationFrame ID used for selection updates.\n   */\n  selectionRafId: number | null = null\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    super(component, props, options)\n\n    if (!this.node.isLeaf) {\n      if (this.options.contentDOMElementTag) {\n        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag)\n      } else {\n        this.contentDOMElement = document.createElement(this.node.isInline ? 'span' : 'div')\n      }\n\n      this.contentDOMElement.dataset.nodeViewContentReact = ''\n      this.contentDOMElement.dataset.nodeViewWrapper = ''\n\n      // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n      // With this fix it seems to work fine\n      // See: https://github.com/ueberdosis/tiptap/issues/1197\n      this.contentDOMElement.style.whiteSpace = 'inherit'\n\n      const contentTarget = this.dom.querySelector('[data-node-view-content]')\n\n      if (!contentTarget) {\n        return\n      }\n\n      contentTarget.appendChild(this.contentDOMElement)\n    }\n  }\n\n  private cachedExtensionWithSyncedStorage: NodeViewRendererProps['extension'] | null = null\n\n  /**\n   * Returns a proxy of the extension that redirects storage access to the editor's mutable storage.\n   * This preserves the original prototype chain (instanceof checks, methods like configure/extend work).\n   * Cached to avoid proxy creation on every update.\n   */\n  get extensionWithSyncedStorage(): NodeViewRendererProps['extension'] {\n    if (!this.cachedExtensionWithSyncedStorage) {\n      const editor = this.editor\n      const extension = this.extension\n\n      this.cachedExtensionWithSyncedStorage = new Proxy(extension, {\n        get(target, prop, receiver) {\n          if (prop === 'storage') {\n            return editor.storage[extension.name as keyof typeof editor.storage] ?? {}\n          }\n          return Reflect.get(target, prop, receiver)\n        },\n      })\n    }\n\n    return this.cachedExtensionWithSyncedStorage\n  }\n\n  /**\n   * Setup the React component.\n   * Called on initialization.\n   */\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations as DecorationWithType[],\n      innerDecorations: this.innerDecorations,\n      view: this.view,\n      selected: false,\n      extension: this.extensionWithSyncedStorage,\n      HTMLAttributes: this.HTMLAttributes,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode(),\n      ref: createRef<T>(),\n    } satisfies ReactNodeViewProps<T>\n\n    if (!(this.component as any).displayName) {\n      const capitalizeFirstChar = (string: string): string => {\n        return string.charAt(0).toUpperCase() + string.substring(1)\n      }\n\n      this.component.displayName = capitalizeFirstChar(this.extension.name)\n    }\n\n    const onDragStart = this.onDragStart.bind(this)\n    const nodeViewContentRef: ReactNodeViewContextProps['nodeViewContentRef'] = element => {\n      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n        // remove the nodeViewWrapper attribute from the element\n        if (element.hasAttribute('data-node-view-wrapper')) {\n          element.removeAttribute('data-node-view-wrapper')\n        }\n        element.appendChild(this.contentDOMElement)\n      }\n    }\n    const context = { onDragStart, nodeViewContentRef }\n    const Component = this.component\n    // For performance reasons, we memoize the provider component\n    // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n    const ReactNodeViewProvider: NamedExoticComponent<ReactNodeViewProps<T>> = memo(componentProps => {\n      return (\n        <ReactNodeViewContext.Provider value={context}>\n          {createElement(Component, componentProps)}\n        </ReactNodeViewContext.Provider>\n      )\n    })\n\n    ReactNodeViewProvider.displayName = 'ReactNodeView'\n\n    let as = this.node.isInline ? 'span' : 'div'\n\n    if (this.options.as) {\n      as = this.options.as\n    }\n\n    const { className = '' } = this.options\n\n    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this)\n\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as,\n      className: `node-${this.node.type.name} ${className}`.trim(),\n    })\n\n    this.editor.on('selectionUpdate', this.handleSelectionUpdate)\n    this.updateElementAttributes()\n  }\n\n  /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */\n  get dom() {\n    if (\n      this.renderer.element.firstElementChild &&\n      !this.renderer.element.firstElementChild?.hasAttribute('data-node-view-wrapper')\n    ) {\n      throw Error('Please use the NodeViewWrapper component for your node view.')\n    }\n\n    return this.renderer.element\n  }\n\n  /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null\n    }\n\n    return this.contentDOMElement\n  }\n\n  /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */\n  handleSelectionUpdate() {\n    if (this.selectionRafId) {\n      cancelAnimationFrame(this.selectionRafId)\n      this.selectionRafId = null\n    }\n\n    this.selectionRafId = requestAnimationFrame(() => {\n      this.selectionRafId = null\n      const { from, to } = this.editor.state.selection\n      const pos = this.getPos()\n      if (typeof pos !== 'number') {\n        return\n      }\n\n      if (from <= pos && to >= pos + this.node.nodeSize) {\n        if (this.renderer.props.selected) {\n          return\n        }\n\n        this.selectNode()\n      } else {\n        if (!this.renderer.props.selected) {\n          return\n        }\n\n        this.deselectNode()\n      }\n    })\n  }\n\n  /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */\n  update(node: Node, decorations: readonly Decoration[], innerDecorations: DecorationSource): boolean {\n    const rerenderComponent = (props?: Record<string, any>) => {\n      this.renderer.updateProps(props)\n      if (typeof this.options.attrs === 'function') {\n        this.updateElementAttributes()\n      }\n    }\n\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    if (typeof this.options.update === 'function') {\n      const oldNode = this.node\n      const oldDecorations = this.decorations\n      const oldInnerDecorations = this.innerDecorations\n\n      this.node = node\n      this.decorations = decorations\n      this.innerDecorations = innerDecorations\n\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        oldInnerDecorations,\n        innerDecorations,\n        updateProps: () =>\n          rerenderComponent({ node, decorations, innerDecorations, extension: this.extensionWithSyncedStorage }),\n      })\n    }\n\n    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n      return true\n    }\n\n    this.node = node\n    this.decorations = decorations\n    this.innerDecorations = innerDecorations\n\n    rerenderComponent({ node, decorations, innerDecorations, extension: this.extensionWithSyncedStorage })\n\n    return true\n  }\n\n  /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true,\n    })\n    this.renderer.element.classList.add('ProseMirror-selectednode')\n  }\n\n  /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false,\n    })\n    this.renderer.element.classList.remove('ProseMirror-selectednode')\n  }\n\n  /**\n   * Destroy the React component instance.\n   */\n  destroy() {\n    this.renderer.destroy()\n    this.editor.off('selectionUpdate', this.handleSelectionUpdate)\n    this.contentDOMElement = null\n\n    if (this.selectionRafId) {\n      cancelAnimationFrame(this.selectionRafId)\n      this.selectionRafId = null\n    }\n  }\n\n  /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */\n  updateElementAttributes() {\n    if (this.options.attrs) {\n      let attrsObj: Record<string, string> = {}\n\n      if (typeof this.options.attrs === 'function') {\n        const extensionAttributes = this.editor.extensionManager.attributes\n        const HTMLAttributes = getRenderedAttributes(this.node, extensionAttributes)\n\n        attrsObj = this.options.attrs({ node: this.node, HTMLAttributes })\n      } else {\n        attrsObj = this.options.attrs\n      }\n\n      this.renderer.updateAttributes(attrsObj)\n    }\n  }\n}\n\n/**\n * Create a React node view renderer.\n */\nexport function ReactNodeViewRenderer<T = HTMLElement>(\n  component: ComponentType<ReactNodeViewProps<T>>,\n  options?: Partial<ReactNodeViewRendererOptions>,\n): NodeViewRenderer {\n  return props => {\n    // try to get the parent component\n    // this is important for vue devtools to show the component hierarchy correctly\n    // maybe its `undefined` because <editor-content> isnt rendered yet\n    if (!(props.editor as EditorWithContentComponent).contentComponent) {\n      return {} as unknown as ProseMirrorNodeView\n    }\n\n    return new ReactNodeView<T>(component, props, options)\n  }\n}\n", "import type { ReactNode } from 'react'\nimport { createContext, useContext, useEffect, useMemo, useState } from 'react'\n\nimport { EditorContext } from './Context.js'\nimport type { Editor, EditorContentProps, EditorStateSnapshot } from './index.js'\nimport { EditorContent, useEditorState } from './index.js'\nimport { type BubbleMenuProps, BubbleMenu } from './menus/BubbleMenu.js'\nimport { type FloatingMenuProps, FloatingMenu } from './menus/FloatingMenu.js'\n\n/**\n * The shape of the React context used by the `<Tiptap />` components.\n *\n * This object exposes the editor instance and a simple readiness flag.\n */\nexport type TiptapContextType = {\n  /** The Tiptap editor instance. May be null during SSR or before initialization. */\n  editor: Editor | null\n\n  /** True when the editor has finished initializing and is ready for user interaction. */\n  isReady: boolean\n}\n\n/**\n * React context that stores the current editor instance and readiness flag.\n *\n * Use `useTiptap()` to read from this context in child components.\n */\nexport const TiptapContext = createContext<TiptapContextType>({\n  editor: null,\n  isReady: false,\n})\n\nTiptapContext.displayName = 'TiptapContext'\n\n/**\n * Hook to read the Tiptap context (`editor` + `isReady`).\n *\n * This is a small convenience wrapper around `useContext(TiptapContext)`.\n *\n * @returns The current `TiptapContextType` value from the provider.\n *\n * @example\n * ```tsx\n * import { useTiptap } from '@tiptap/react'\n *\n * function Status() {\n *   const { isReady } = useTiptap()\n *   return <div>{isReady ? 'Editor ready' : 'Loading editor...'}</div>\n * }\n * ```\n */\nexport const useTiptap = () => useContext(TiptapContext)\n\n/**\n * Select a slice of the editor state using the context-provided editor.\n *\n * This is a thin wrapper around `useEditorState` that reads the `editor`\n * instance from `useTiptap()` so callers don't have to pass it manually.\n *\n * Important: This hook should only be used when the editor is available.\n * Use the `isReady` flag from `useTiptap()` to guard against null editor,\n * or ensure your component only renders after the editor is initialized.\n *\n * @typeParam TSelectorResult - The type returned by the selector.\n * @param selector - Function that receives the editor state snapshot and\n *                   returns the piece of state you want to subscribe to.\n * @param equalityFn - Optional function to compare previous/next selected\n *                     values and avoid unnecessary updates.\n * @returns The selected slice of the editor state.\n *\n * @example\n * ```tsx\n * function WordCount() {\n *   const { isReady } = useTiptap()\n *\n *   // Only use useTiptapState when the editor is ready\n *   const wordCount = useTiptapState(state => {\n *     const text = state.editor.state.doc.textContent\n *     return text.split(/\\s+/).filter(Boolean).length\n *   })\n *\n *   if (!isReady) return null\n *\n *   return <span>{wordCount} words</span>\n * }\n * ```\n */\nexport function useTiptapState<TSelectorResult>(\n  selector: (context: EditorStateSnapshot<Editor>) => TSelectorResult,\n  equalityFn?: (a: TSelectorResult, b: TSelectorResult | null) => boolean,\n) {\n  const { editor } = useTiptap()\n  return useEditorState({\n    editor: editor as Editor,\n    selector,\n    equalityFn,\n  })\n}\n\n/**\n * Props for the `Tiptap` root/provider component.\n */\nexport type TiptapWrapperProps = {\n  /**\n   * The editor instance to provide to child components.\n   * Can be null during SSR or before initialization.\n   */\n  instance: Editor | null\n  children: ReactNode\n}\n\n/**\n * Top-level provider component that makes the editor instance available via\n * React context and tracks when the editor becomes ready.\n *\n * The component listens to the editor's `create` event and flips the\n * `isReady` flag once initialization completes.\n *\n * This component also provides backwards compatibility with the legacy\n * `EditorContext`, so components using `useCurrentEditor()` will work\n * inside a `<Tiptap>` provider.\n *\n * @param props - Component props.\n * @returns A context provider element wrapping `children`.\n *\n * @example\n * ```tsx\n * import { Tiptap, useEditor } from '@tiptap/react'\n *\n * function App() {\n *   const editor = useEditor({ extensions: [...] })\n *\n *   return (\n *     <Tiptap instance={editor}>\n *       <Toolbar />\n *       <Tiptap.Content />\n *     </Tiptap>\n *   )\n * }\n * ```\n */\nexport function TiptapWrapper({ instance, children }: TiptapWrapperProps) {\n  const [isReady, setIsReady] = useState(instance?.isInitialized ?? false)\n\n  useEffect(() => {\n    if (!instance) {\n      setIsReady(false)\n      return\n    }\n\n    // If the editor is already initialized, set isReady to true\n    if (instance.isInitialized) {\n      setIsReady(true)\n      return\n    }\n\n    const handleCreate = () => {\n      setIsReady(true)\n    }\n\n    instance.on('create', handleCreate)\n\n    return () => {\n      instance.off('create', handleCreate)\n    }\n  }, [instance])\n\n  // Memoize context values to prevent unnecessary re-renders\n  const tiptapContextValue = useMemo<TiptapContextType>(() => ({ editor: instance, isReady }), [instance, isReady])\n\n  // Provide backwards compatibility with the legacy EditorContext\n  // so components using useCurrentEditor() work inside <Tiptap>\n  const legacyContextValue = useMemo(() => ({ editor: instance }), [instance])\n\n  return (\n    <EditorContext.Provider value={legacyContextValue}>\n      <TiptapContext.Provider value={tiptapContextValue}>{children}</TiptapContext.Provider>\n    </EditorContext.Provider>\n  )\n}\n\nTiptapWrapper.displayName = 'Tiptap'\n\n/**\n * Convenience component that renders `EditorContent` using the context-provided\n * editor instance. Use this instead of manually passing the `editor` prop.\n *\n * @param props - All `EditorContent` props except `editor` and `ref`.\n * @returns An `EditorContent` element bound to the context editor.\n *\n * @example\n * ```tsx\n * // inside a Tiptap provider\n * <Tiptap.Content className=\"editor\" />\n * ```\n */\nexport function TiptapContent({ ...rest }: Omit<EditorContentProps, 'editor' | 'ref'>) {\n  const { editor } = useTiptap()\n\n  return <EditorContent editor={editor} {...rest} />\n}\n\nTiptapContent.displayName = 'Tiptap.Content'\n\nexport type TiptapLoadingProps = {\n  children: ReactNode\n}\n\n/**\n * Component that renders its children only when the editor is not ready.\n *\n * This is useful for displaying loading states or placeholders during\n * editor initialization, especially with SSR.\n *\n * @param props - The props for the TiptapLoading component.\n * @returns The children when editor is not ready, or null when ready.\n *\n * @example\n * ```tsx\n * <Tiptap instance={editor}>\n *   <Tiptap.Loading>\n *     <div className=\"skeleton\">Loading editor...</div>\n *   </Tiptap.Loading>\n *   <Tiptap.Content />\n * </Tiptap>\n * ```\n */\nexport function TiptapLoading({ children }: TiptapLoadingProps) {\n  const { isReady } = useTiptap()\n\n  if (isReady) {\n    return null\n  }\n\n  return children\n}\n\nTiptapLoading.displayName = 'Tiptap.Loading'\n\n/**\n * A wrapper around the library `BubbleMenu` that injects the editor from\n * context so callers don't need to pass the `editor` prop.\n *\n * Returns `null` when the editor is not available (for example during SSR).\n *\n * @param props - Props for the underlying `BubbleMenu` (except `editor`).\n * @returns A `BubbleMenu` bound to the context editor, or `null`.\n *\n * @example\n * ```tsx\n * <Tiptap.BubbleMenu tippyOptions={{ duration: 100 }}>\n *   <button onClick={() => editor.chain().focus().toggleBold().run()}>Bold</button>\n * </Tiptap.BubbleMenu>\n * ```\n */\nexport function TiptapBubbleMenu({ children, ...rest }: { children: ReactNode } & Omit<BubbleMenuProps, 'editor'>) {\n  const { editor } = useTiptap()\n\n  if (!editor) {\n    return null\n  }\n\n  return (\n    <BubbleMenu editor={editor} {...rest}>\n      {children}\n    </BubbleMenu>\n  )\n}\n\nTiptapBubbleMenu.displayName = 'Tiptap.BubbleMenu'\n\n/**\n * A wrapper around the library `FloatingMenu` that injects the editor from\n * context so callers don't need to pass the `editor` prop.\n *\n * Returns `null` when the editor is not available.\n *\n * @param props - Props for the underlying `FloatingMenu` (except `editor`).\n * @returns A `FloatingMenu` bound to the context editor, or `null`.\n *\n * @example\n * ```tsx\n * <Tiptap.FloatingMenu placement=\"top\">\n *   <button onClick={() => editor.chain().focus().toggleItalic().run()}>Italic</button>\n * </Tiptap.FloatingMenu>\n * ```\n */\nexport function TiptapFloatingMenu({ children, ...rest }: { children: ReactNode } & Omit<FloatingMenuProps, 'editor'>) {\n  const { editor } = useTiptap()\n\n  if (!editor) {\n    return null\n  }\n\n  return (\n    <FloatingMenu {...rest} editor={editor}>\n      {children}\n    </FloatingMenu>\n  )\n}\n\nTiptapFloatingMenu.displayName = 'Tiptap.FloatingMenu'\n\n/**\n * Root `Tiptap` component. Use it as the provider for all child components.\n *\n * The exported object includes several helper subcomponents for common use\n * cases: `Content`, `Loading`, `BubbleMenu`, and `FloatingMenu`.\n *\n * This component provides both the new `TiptapContext` (accessed via `useTiptap()`)\n * and the legacy `EditorContext` (accessed via `useCurrentEditor()`) for\n * backwards compatibility.\n *\n * @example\n * ```tsx\n * const editor = useEditor({ extensions: [...] })\n *\n * return (\n *   <Tiptap instance={editor}>\n *     <Tiptap.Loading>Initializing editor...</Tiptap.Loading>\n *     <Tiptap.Content />\n *     <Tiptap.BubbleMenu>\n *       <button onClick={() => editor.chain().focus().toggleBold().run()}>Bold</button>\n *     </Tiptap.BubbleMenu>\n *   </Tiptap>\n * )\n * ```\n */\nexport const Tiptap = Object.assign(TiptapWrapper, {\n  /**\n   * The Tiptap Content component that renders the EditorContent with the editor instance from the context.\n   * @see TiptapContent\n   */\n  Content: TiptapContent,\n\n  /**\n   * The Tiptap Loading component that renders its children only when the editor is not ready.\n   * @see TiptapLoading\n   */\n  Loading: TiptapLoading,\n\n  /**\n   * The Tiptap BubbleMenu component that wraps the BubbleMenu from Tiptap and provides the editor instance from the context.\n   * @see TiptapBubbleMenu\n   */\n  BubbleMenu: TiptapBubbleMenu,\n\n  /**\n   * The Tiptap FloatingMenu component that wraps the FloatingMenu from Tiptap and provides the editor instance from the context.\n   * @see TiptapFloatingMenu\n   */\n  FloatingMenu: TiptapFloatingMenu,\n})\n\nexport default Tiptap\n", "import { type BubbleMenuPluginProps, BubbleMenuPlugin } from '@tiptap/extension-bubble-menu'\nimport { useCurrentEditor } from '@tiptap/react'\nimport React, { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\ntype Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type BubbleMenuProps = Optional<Omit<Optional<BubbleMenuPluginProps, 'pluginKey'>, 'element'>, 'editor'> &\n  React.HTMLAttributes<HTMLDivElement>\n\nexport const BubbleMenu = React.forwardRef<HTMLDivElement, BubbleMenuProps>(\n  (\n    {\n      pluginKey = 'bubbleMenu',\n      editor,\n      updateDelay,\n      resizeDelay,\n      appendTo,\n      shouldShow = null,\n      getReferencedVirtualElement,\n      options,\n      children,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const menuEl = useRef(document.createElement('div'))\n\n    if (typeof ref === 'function') {\n      ref(menuEl.current)\n    } else if (ref) {\n      ref.current = menuEl.current\n    }\n\n    const { editor: currentEditor } = useCurrentEditor()\n\n    /**\n     * The editor instance where the bubble menu plugin will be registered.\n     */\n    const pluginEditor = editor || currentEditor\n\n    // Creating a useMemo would be more computationally expensive than just\n    // re-creating this object on every render.\n    const bubbleMenuPluginProps: Omit<BubbleMenuPluginProps, 'editor' | 'element'> = {\n      updateDelay,\n      resizeDelay,\n      appendTo,\n      pluginKey,\n      shouldShow,\n      getReferencedVirtualElement,\n      options,\n    }\n    /**\n     * The props for the bubble menu plugin. They are accessed inside a ref to\n     * avoid running the useEffect hook and re-registering the plugin when the\n     * props change.\n     */\n    const bubbleMenuPluginPropsRef = useRef(bubbleMenuPluginProps)\n    bubbleMenuPluginPropsRef.current = bubbleMenuPluginProps\n\n    /**\n     * Track whether the plugin has been initialized, so we only send updates\n     * after the initial registration.\n     */\n    const [pluginInitialized, setPluginInitialized] = useState(false)\n\n    /**\n     * Track whether we need to skip the first options update dispatch.\n     * This prevents unnecessary updates right after plugin initialization.\n     */\n    const skipFirstUpdateRef = useRef(true)\n\n    useEffect(() => {\n      if (pluginEditor?.isDestroyed) {\n        return\n      }\n\n      if (!pluginEditor) {\n        console.warn('BubbleMenu component is not rendered inside of an editor component or does not have editor prop.')\n        return\n      }\n\n      const bubbleMenuElement = menuEl.current\n      bubbleMenuElement.style.visibility = 'hidden'\n      bubbleMenuElement.style.position = 'absolute'\n\n      const plugin = BubbleMenuPlugin({\n        ...bubbleMenuPluginPropsRef.current,\n        editor: pluginEditor,\n        element: bubbleMenuElement,\n      })\n\n      pluginEditor.registerPlugin(plugin)\n\n      const createdPluginKey = bubbleMenuPluginPropsRef.current.pluginKey\n\n      skipFirstUpdateRef.current = true\n      setPluginInitialized(true)\n\n      return () => {\n        setPluginInitialized(false)\n        pluginEditor.unregisterPlugin(createdPluginKey)\n        window.requestAnimationFrame(() => {\n          if (bubbleMenuElement.parentNode) {\n            bubbleMenuElement.parentNode.removeChild(bubbleMenuElement)\n          }\n        })\n      }\n    }, [pluginEditor])\n\n    /**\n     * Update the plugin options when props change after the plugin has been initialized.\n     * This allows dynamic updates to options like scrollTarget without re-registering the entire plugin.\n     */\n    useEffect(() => {\n      if (!pluginInitialized || !pluginEditor || pluginEditor.isDestroyed) {\n        return\n      }\n\n      // Skip the first update right after initialization since the plugin was just created with these options\n      if (skipFirstUpdateRef.current) {\n        skipFirstUpdateRef.current = false\n        return\n      }\n\n      pluginEditor.view.dispatch(\n        pluginEditor.state.tr.setMeta('bubbleMenu', {\n          type: 'updateOptions',\n          options: bubbleMenuPluginPropsRef.current,\n        }),\n      )\n    }, [\n      pluginInitialized,\n      pluginEditor,\n      updateDelay,\n      resizeDelay,\n      shouldShow,\n      options,\n      appendTo,\n      getReferencedVirtualElement,\n    ])\n\n    return createPortal(<div {...restProps}>{children}</div>, menuEl.current)\n  },\n)\n", "import type { FloatingMenuPluginProps } from '@tiptap/extension-floating-menu'\nimport { FloatingMenuPlugin } from '@tiptap/extension-floating-menu'\nimport { useCurrentEditor } from '@tiptap/react'\nimport React, { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\ntype Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type FloatingMenuProps = Omit<Optional<FloatingMenuPluginProps, 'pluginKey'>, 'element' | 'editor'> & {\n  editor: FloatingMenuPluginProps['editor'] | null\n  options?: FloatingMenuPluginProps['options']\n} & React.HTMLAttributes<HTMLDivElement>\n\nexport const FloatingMenu = React.forwardRef<HTMLDivElement, FloatingMenuProps>(\n  (\n    {\n      pluginKey = 'floatingMenu',\n      editor,\n      updateDelay,\n      resizeDelay,\n      appendTo,\n      shouldShow = null,\n      options,\n      children,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const menuEl = useRef(document.createElement('div'))\n\n    if (typeof ref === 'function') {\n      ref(menuEl.current)\n    } else if (ref) {\n      ref.current = menuEl.current\n    }\n\n    const { editor: currentEditor } = useCurrentEditor()\n\n    /**\n     * The editor instance where the floating menu plugin will be registered.\n     */\n    const pluginEditor = editor || currentEditor\n\n    // Creating a useMemo would be more computationally expensive than just\n    // re-creating this object on every render.\n    const floatingMenuPluginProps: Omit<FloatingMenuPluginProps, 'editor' | 'element'> = {\n      updateDelay,\n      resizeDelay,\n      appendTo,\n      pluginKey,\n      shouldShow,\n      options,\n    }\n\n    /**\n     * The props for the floating menu plugin. They are accessed inside a ref to\n     * avoid running the useEffect hook and re-registering the plugin when the\n     * props change.\n     */\n    const floatingMenuPluginPropsRef = useRef(floatingMenuPluginProps)\n    floatingMenuPluginPropsRef.current = floatingMenuPluginProps\n\n    /**\n     * Track whether the plugin has been initialized, so we only send updates\n     * after the initial registration.\n     */\n    const [pluginInitialized, setPluginInitialized] = useState(false)\n\n    /**\n     * Track whether we need to skip the first options update dispatch.\n     * This prevents unnecessary updates right after plugin initialization.\n     */\n    const skipFirstUpdateRef = useRef(true)\n\n    useEffect(() => {\n      if (pluginEditor?.isDestroyed) {\n        return\n      }\n\n      if (!pluginEditor) {\n        console.warn(\n          'FloatingMenu component is not rendered inside of an editor component or does not have editor prop.',\n        )\n        return\n      }\n\n      const floatingMenuElement = menuEl.current\n      floatingMenuElement.style.visibility = 'hidden'\n      floatingMenuElement.style.position = 'absolute'\n\n      const plugin = FloatingMenuPlugin({\n        ...floatingMenuPluginPropsRef.current,\n        editor: pluginEditor,\n        element: floatingMenuElement,\n      })\n\n      pluginEditor.registerPlugin(plugin)\n\n      const createdPluginKey = floatingMenuPluginPropsRef.current.pluginKey\n\n      skipFirstUpdateRef.current = true\n      setPluginInitialized(true)\n\n      return () => {\n        setPluginInitialized(false)\n        pluginEditor.unregisterPlugin(createdPluginKey)\n        window.requestAnimationFrame(() => {\n          if (floatingMenuElement.parentNode) {\n            floatingMenuElement.parentNode.removeChild(floatingMenuElement)\n          }\n        })\n      }\n    }, [pluginEditor])\n\n    /**\n     * Update the plugin options when props change after the plugin has been initialized.\n     * This allows dynamic updates to options like scrollTarget without re-registering the entire plugin.\n     */\n    useEffect(() => {\n      if (!pluginInitialized || !pluginEditor || pluginEditor.isDestroyed) {\n        return\n      }\n\n      // Skip the first update right after initialization since the plugin was just created with these options\n      if (skipFirstUpdateRef.current) {\n        skipFirstUpdateRef.current = false\n        return\n      }\n\n      pluginEditor.view.dispatch(\n        pluginEditor.state.tr.setMeta('floatingMenu', {\n          type: 'updateOptions',\n          options: floatingMenuPluginPropsRef.current,\n        }),\n      )\n    }, [pluginInitialized, pluginEditor, updateDelay, resizeDelay, shouldShow, options, appendTo])\n\n    return createPortal(<div {...restProps}>{children}</div>, menuEl.current)\n  },\n)\n", "export * from './Context.js'\nexport * from './EditorContent.js'\nexport * from './NodeViewContent.js'\nexport * from './NodeViewWrapper.js'\nexport * from './ReactMarkViewRenderer.js'\nexport * from './ReactNodeViewRenderer.js'\nexport * from './ReactRenderer.js'\nexport * from './Tiptap.js'\nexport * from './types.js'\nexport * from './useEditor.js'\nexport * from './useEditorState.js'\nexport * from './useReactNodeView.js'\nexport * from '@tiptap/core'\n", "import type {\n  AnyEqualityComparator,\n  Cache,\n  CircularState,\n  Dictionary,\n  State,\n  TypeEqualityComparator,\n} from './internalTypes.js';\n\nconst { getOwnPropertyNames, getOwnPropertySymbols } = Object;\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n * Combine two comparators into a single comparators.\n */\nexport function combineComparators<Meta>(\n  comparatorA: AnyEqualityComparator<Meta>,\n  comparatorB: AnyEqualityComparator<Meta>,\n) {\n  return function isEqual<A, B>(a: A, b: B, state: State<Meta>) {\n    return comparatorA(a, b, state) && comparatorB(a, b, state);\n  };\n}\n\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nexport function createIsCircular<AreItemsEqual extends TypeEqualityComparator<any, any>>(\n  areItemsEqual: AreItemsEqual,\n): AreItemsEqual {\n  return function isCircular(a: any, b: any, state: CircularState<Cache<any, any>>) {\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return areItemsEqual(a, b, state);\n    }\n\n    const { cache } = state;\n\n    const cachedA = cache.get(a);\n    const cachedB = cache.get(b);\n\n    if (cachedA && cachedB) {\n      return cachedA === b && cachedB === a;\n    }\n\n    cache.set(a, b);\n    cache.set(b, a);\n\n    const result = areItemsEqual(a, b, state);\n\n    cache.delete(a);\n    cache.delete(b);\n\n    return result;\n  } as AreItemsEqual;\n}\n\n/**\n * Get the `@@toStringTag` of the value, if it exists.\n */\nexport function getShortTag(value: any): string | undefined {\n  return value != null ? (value[Symbol.toStringTag] as string) : undefined;\n}\n\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */\nexport function getStrictProperties(object: Dictionary): Array<string | symbol> {\n  return (getOwnPropertyNames(object) as Array<string | symbol>).concat(getOwnPropertySymbols(object));\n}\n\n/**\n * Whether the object contains the property passed as an own property.\n */\nexport const hasOwn =\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  Object.hasOwn || ((object: Dictionary, property: number | string | symbol) => hasOwnProperty.call(object, property));\n\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nexport function sameValueZeroEqual(a: any, b: any): boolean {\n  return a === b || (!a && !b && a !== a && b !== b);\n}\n", "import type { Dictionary, PrimitiveWrapper, State, TypedArray } from './internalTypes.js';\nimport { getStrictProperties, hasOwn, sameValueZeroEqual } from './utils.js';\n\nconst PREACT_VNODE = '__v';\nconst PREACT_OWNER = '__o';\nconst REACT_OWNER = '_owner';\n\nconst { getOwnPropertyDescriptor, keys } = Object;\n\n/**\n * Whether the array buffers are equal in value.\n */\nexport function areArrayBuffersEqual(a: ArrayBuffer, b: ArrayBuffer): boolean {\n  return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a), new Uint8Array(b));\n}\n\n/**\n * Whether the arrays are equal in value.\n */\nexport function areArraysEqual(a: any[], b: any[], state: State<any>) {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the dataviews are equal in value.\n */\nexport function areDataViewsEqual(a: DataView, b: DataView): boolean {\n  return (\n    a.byteLength === b.byteLength\n    && areTypedArraysEqual(\n      new Uint8Array(a.buffer, a.byteOffset, a.byteLength),\n      new Uint8Array(b.buffer, b.byteOffset, b.byteLength),\n    )\n  );\n}\n\n/**\n * Whether the dates passed are equal in value.\n */\nexport function areDatesEqual(a: Date, b: Date): boolean {\n  return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n\n/**\n * Whether the errors passed are equal in value.\n */\nexport function areErrorsEqual(a: Error, b: Error): boolean {\n  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;\n}\n\n/**\n * Whether the functions passed are equal in value.\n */\nexport function areFunctionsEqual(a: (...args: any[]) => any, b: (...args: any[]) => any): boolean {\n  return a === b;\n}\n\n/**\n * Whether the `Map`s are equal in value.\n */\nexport function areMapsEqual(a: Map<any, any>, b: Map<any, any>, state: State<any>): boolean {\n  const size = a.size;\n\n  if (size !== b.size) {\n    return false;\n  }\n\n  if (!size) {\n    return true;\n  }\n\n  const matchedIndices = new Array<true | undefined>(size);\n  const aIterable = a.entries();\n\n  let aResult: IteratorResult<[any, any]>;\n  let bResult: IteratorResult<[any, any]>;\n  let index = 0;\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  while ((aResult = aIterable.next())) {\n    if (aResult.done) {\n      break;\n    }\n\n    const bIterable = b.entries();\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while ((bResult = bIterable.next())) {\n      if (bResult.done) {\n        break;\n      }\n\n      if (matchedIndices[matchIndex]) {\n        matchIndex++;\n        continue;\n      }\n\n      const aEntry = aResult.value;\n      const bEntry = bResult.value;\n\n      if (\n        state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state)\n        && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)\n      ) {\n        hasMatch = matchedIndices[matchIndex] = true;\n        break;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n\n    index++;\n  }\n\n  return true;\n}\n\n/**\n * Whether the numbers are equal in value.\n */\nexport const areNumbersEqual = sameValueZeroEqual;\n\n/**\n * Whether the objects are equal in value.\n */\nexport function areObjectsEqual(a: Dictionary, b: Dictionary, state: State<any>): boolean {\n  const properties = keys(a);\n\n  let index = properties.length;\n\n  if (keys(b).length !== index) {\n    return false;\n  }\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    if (!isPropertyEqual(a, b, state, properties[index]!)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the objects are equal in value with strict property checking.\n */\nexport function areObjectsEqualStrict(a: Dictionary, b: Dictionary, state: State<any>): boolean {\n  const properties = getStrictProperties(a);\n\n  let index = properties.length;\n\n  if (getStrictProperties(b).length !== index) {\n    return false;\n  }\n\n  let property: string | symbol;\n  let descriptorA: ReturnType<typeof getOwnPropertyDescriptor>;\n  let descriptorB: ReturnType<typeof getOwnPropertyDescriptor>;\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    property = properties[index]!;\n\n    if (!isPropertyEqual(a, b, state, property)) {\n      return false;\n    }\n\n    descriptorA = getOwnPropertyDescriptor(a, property);\n    descriptorB = getOwnPropertyDescriptor(b, property);\n\n    if (\n      (descriptorA || descriptorB)\n      && (!descriptorA\n        || !descriptorB\n        || descriptorA.configurable !== descriptorB.configurable\n        || descriptorA.enumerable !== descriptorB.enumerable\n        || descriptorA.writable !== descriptorB.writable)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the primitive wrappers passed are equal in value.\n */\nexport function arePrimitiveWrappersEqual(a: PrimitiveWrapper, b: PrimitiveWrapper): boolean {\n  return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n\n/**\n * Whether the regexps passed are equal in value.\n */\nexport function areRegExpsEqual(a: RegExp, b: RegExp): boolean {\n  return a.source === b.source && a.flags === b.flags;\n}\n\n/**\n * Whether the `Set`s are equal in value.\n */\nexport function areSetsEqual(a: Set<any>, b: Set<any>, state: State<any>): boolean {\n  const size = a.size;\n\n  if (size !== b.size) {\n    return false;\n  }\n\n  if (!size) {\n    return true;\n  }\n\n  const matchedIndices = new Array<true | undefined>(size);\n  const aIterable = a.values();\n\n  let aResult: IteratorResult<any>;\n  let bResult: IteratorResult<any>;\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  while ((aResult = aIterable.next())) {\n    if (aResult.done) {\n      break;\n    }\n\n    const bIterable = b.values();\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while ((bResult = bIterable.next())) {\n      if (bResult.done) {\n        break;\n      }\n\n      if (\n        !matchedIndices[matchIndex]\n        && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)\n      ) {\n        hasMatch = matchedIndices[matchIndex] = true;\n        break;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the TypedArray instances are equal in value.\n */\nexport function areTypedArraysEqual(a: TypedArray, b: TypedArray) {\n  let index = a.byteLength;\n\n  if (b.byteLength !== index || a.byteOffset !== b.byteOffset) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the URL instances are equal in value.\n */\nexport function areUrlsEqual(a: URL, b: URL): boolean {\n  return (\n    a.hostname === b.hostname\n    && a.pathname === b.pathname\n    && a.protocol === b.protocol\n    && a.port === b.port\n    && a.hash === b.hash\n    && a.username === b.username\n    && a.password === b.password\n  );\n}\n\nfunction isPropertyEqual(a: Dictionary, b: Dictionary, state: State<any>, property: string | symbol) {\n  if (\n    (property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE)\n    && (a.$$typeof || b.$$typeof)\n  ) {\n    return true;\n  }\n\n  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);\n}\n", "import {\n  areArrayBuffersEqual,\n  areArraysEqual as areArraysEqualDefault,\n  areDataViewsEqual,\n  areDatesEqual as areDatesEqualDefault,\n  areErrorsEqual as areErrorsEqualDefault,\n  areFunctionsEqual as areFunctionsEqualDefault,\n  areMapsEqual as areMapsEqualDefault,\n  areNumbersEqual as areNumbersEqualDefault,\n  areObjectsEqual as areObjectsEqualDefault,\n  areObjectsEqualStrict as areObjectsEqualStrictDefault,\n  arePrimitiveWrappersEqual as arePrimitiveWrappersEqualDefault,\n  areRegExpsEqual as areRegExpsEqualDefault,\n  areSetsEqual as areSetsEqualDefault,\n  areTypedArraysEqual as areTypedArraysEqualDefault,\n  areUrlsEqual as areUrlsEqualDefault,\n} from './equals.js';\nimport type {\n  ComparatorConfig,\n  CreateState,\n  CustomEqualCreatorOptions,\n  EqualityComparator,\n  InternalEqualityComparator,\n  State,\n} from './internalTypes.js';\nimport { combineComparators, createIsCircular, getShortTag } from './utils.js';\n\nconst ARRAY_BUFFER_TAG = '[object ArrayBuffer]';\nconst ARGUMENTS_TAG = '[object Arguments]';\nconst BOOLEAN_TAG = '[object Boolean]';\nconst DATA_VIEW_TAG = '[object DataView]';\nconst DATE_TAG = '[object Date]';\nconst ERROR_TAG = '[object Error]';\nconst MAP_TAG = '[object Map]';\nconst NUMBER_TAG = '[object Number]';\nconst OBJECT_TAG = '[object Object]';\nconst REG_EXP_TAG = '[object RegExp]';\nconst SET_TAG = '[object Set]';\nconst STRING_TAG = '[object String]';\nconst TYPED_ARRAY_TAGS: Record<string, boolean> = {\n  '[object Int8Array]': true,\n  '[object Uint8Array]': true,\n  '[object Uint8ClampedArray]': true,\n  '[object Int16Array]': true,\n  '[object Uint16Array]': true,\n  '[object Int32Array]': true,\n  '[object Uint32Array]': true,\n  '[object Float16Array]': true,\n  '[object Float32Array]': true,\n  '[object Float64Array]': true,\n  '[object BigInt64Array]': true,\n  '[object BigUint64Array]': true,\n};\nconst URL_TAG = '[object URL]';\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst toString = Object.prototype.toString;\n\ninterface CreateIsEqualOptions<Meta> {\n  circular: boolean;\n  comparator: EqualityComparator<Meta>;\n  createState: CreateState<Meta> | undefined;\n  equals: InternalEqualityComparator<Meta>;\n  strict: boolean;\n}\n\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */\nexport function createEqualityComparator<Meta>({\n  areArrayBuffersEqual,\n  areArraysEqual,\n  areDataViewsEqual,\n  areDatesEqual,\n  areErrorsEqual,\n  areFunctionsEqual,\n  areMapsEqual,\n  areNumbersEqual,\n  areObjectsEqual,\n  arePrimitiveWrappersEqual,\n  areRegExpsEqual,\n  areSetsEqual,\n  areTypedArraysEqual,\n  areUrlsEqual,\n  unknownTagComparators,\n}: ComparatorConfig<Meta>): EqualityComparator<Meta> {\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   */\n  return function comparator(a: any, b: any, state: State<Meta>): boolean {\n    // If the items are strictly equal, no need to do a value comparison.\n    if (a === b) {\n      return true;\n    }\n\n    // If either of the items are nullish and fail the strictly equal check\n    // above, then they must be unequal.\n    if (a == null || b == null) {\n      return false;\n    }\n\n    const type = typeof a;\n\n    if (type !== typeof b) {\n      return false;\n    }\n\n    if (type !== 'object') {\n      if (type === 'number') {\n        return areNumbersEqual(a, b, state);\n      }\n\n      if (type === 'function') {\n        return areFunctionsEqual(a, b, state);\n      }\n\n      // If a primitive value that is not strictly equal, it must be unequal.\n      return false;\n    }\n\n    const constructor = a.constructor;\n\n    // Checks are listed in order of commonality of use-case:\n    //   1. Common complex object types (plain object, array)\n    //   2. Common data values (date, regexp)\n    //   3. Less-common complex object types (map, set)\n    //   4. Less-common data values (promise, primitive wrappers)\n    // Inherently this is both subjective and assumptive, however\n    // when reviewing comparable libraries in the wild this order\n    // appears to be generally consistent.\n\n    // Constructors should match, otherwise there is potential for false positives\n    // between class and subclass or custom object and POJO.\n    if (constructor !== b.constructor) {\n      return false;\n    }\n\n    // `isPlainObject` only checks against the object's own realm. Cross-realm\n    // comparisons are rare, and will be handled in the ultimate fallback, so\n    // we can avoid capturing the string tag.\n    if (constructor === Object) {\n      return areObjectsEqual(a, b, state);\n    }\n\n    // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n    // the string tag or doing an `instanceof` check.\n    if (Array.isArray(a)) {\n      return areArraysEqual(a, b, state);\n    }\n\n    // Try to fast-path equality checks for other complex object types in the\n    // same realm to avoid capturing the string tag. Strict equality is used\n    // instead of `instanceof` because it is more performant for the common\n    // use-case. If someone is subclassing a native class, it will be handled\n    // with the string tag comparison.\n\n    if (constructor === Date) {\n      return areDatesEqual(a, b, state);\n    }\n\n    if (constructor === RegExp) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (constructor === Map) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (constructor === Set) {\n      return areSetsEqual(a, b, state);\n    }\n\n    // Since this is a custom object, capture the string tag to determing its type.\n    // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n    const tag = toString.call(a);\n\n    if (tag === DATE_TAG) {\n      return areDatesEqual(a, b, state);\n    }\n\n    // For RegExp, the properties are not enumerable, and therefore will give false positives if\n    // tested like a standard object.\n    if (tag === REG_EXP_TAG) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (tag === MAP_TAG) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (tag === SET_TAG) {\n      return areSetsEqual(a, b, state);\n    }\n\n    if (tag === OBJECT_TAG) {\n      // The exception for value comparison is custom `Promise`-like class instances. These should\n      // be treated the same as standard `Promise` objects, which means strict equality, and if\n      // it reaches this point then that strict equality comparison has already failed.\n      return typeof a.then !== 'function' && typeof b.then !== 'function' && areObjectsEqual(a, b, state);\n    }\n\n    // If a URL tag, it should be tested explicitly. Like RegExp, the properties are not\n    // enumerable, and therefore will give false positives if tested like a standard object.\n    if (tag === URL_TAG) {\n      return areUrlsEqual(a, b, state);\n    }\n\n    // If an error tag, it should be tested explicitly. Like RegExp, the properties are not\n    // enumerable, and therefore will give false positives if tested like a standard object.\n    if (tag === ERROR_TAG) {\n      return areErrorsEqual(a, b, state);\n    }\n\n    // If an arguments tag, it should be treated as a standard object.\n    if (tag === ARGUMENTS_TAG) {\n      return areObjectsEqual(a, b, state);\n    }\n\n    if (TYPED_ARRAY_TAGS[tag]) {\n      return areTypedArraysEqual(a, b, state);\n    }\n\n    if (tag === ARRAY_BUFFER_TAG) {\n      return areArrayBuffersEqual(a, b, state);\n    }\n\n    if (tag === DATA_VIEW_TAG) {\n      return areDataViewsEqual(a, b, state);\n    }\n\n    // As the penultimate fallback, check if the values passed are primitive wrappers. This\n    // is very rare in modern JS, which is why it is deprioritized compared to all other object\n    // types.\n    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n      return arePrimitiveWrappersEqual(a, b, state);\n    }\n\n    if (unknownTagComparators) {\n      let unknownTagComparator = unknownTagComparators[tag];\n\n      if (!unknownTagComparator) {\n        const shortTag = getShortTag(a);\n\n        if (shortTag) {\n          unknownTagComparator = unknownTagComparators[shortTag];\n        }\n      }\n\n      // If the custom config has an unknown tag comparator that matches the captured tag or the\n      // @@toStringTag, it is the source of truth for whether the values are equal.\n      if (unknownTagComparator) {\n        return unknownTagComparator(a, b, state);\n      }\n    }\n\n    // If not matching any tags that require a specific type of comparison, then we hard-code false because\n    // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n    //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n    //     comparison that can be made.\n    //   - For types that can be introspected, but rarely have requirements to be compared\n    //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n    //     use-cases (may be included in a future release, if requested enough).\n    //   - For types that can be introspected but do not have an objective definition of what\n    //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n    // In all cases, these decisions should be reevaluated based on changes to the language and\n    // common development practices.\n    return false;\n  };\n}\n\n/**\n * Create the configuration object used for building comparators.\n */\nexport function createEqualityComparatorConfig<Meta>({\n  circular,\n  createCustomConfig,\n  strict,\n}: CustomEqualCreatorOptions<Meta>): ComparatorConfig<Meta> {\n  let config = {\n    areArrayBuffersEqual,\n    areArraysEqual: strict ? areObjectsEqualStrictDefault : areArraysEqualDefault,\n    areDataViewsEqual,\n    areDatesEqual: areDatesEqualDefault,\n    areErrorsEqual: areErrorsEqualDefault,\n    areFunctionsEqual: areFunctionsEqualDefault,\n    areMapsEqual: strict ? combineComparators(areMapsEqualDefault, areObjectsEqualStrictDefault) : areMapsEqualDefault,\n    areNumbersEqual: areNumbersEqualDefault,\n    areObjectsEqual: strict ? areObjectsEqualStrictDefault : areObjectsEqualDefault,\n    arePrimitiveWrappersEqual: arePrimitiveWrappersEqualDefault,\n    areRegExpsEqual: areRegExpsEqualDefault,\n    areSetsEqual: strict ? combineComparators(areSetsEqualDefault, areObjectsEqualStrictDefault) : areSetsEqualDefault,\n    areTypedArraysEqual: strict\n      ? combineComparators(areTypedArraysEqualDefault, areObjectsEqualStrictDefault)\n      : areTypedArraysEqualDefault,\n    areUrlsEqual: areUrlsEqualDefault,\n    unknownTagComparators: undefined,\n  };\n\n  if (createCustomConfig) {\n    config = Object.assign({}, config, createCustomConfig(config));\n  }\n\n  if (circular) {\n    const areArraysEqual = createIsCircular(config.areArraysEqual);\n    const areMapsEqual = createIsCircular(config.areMapsEqual);\n    const areObjectsEqual = createIsCircular(config.areObjectsEqual);\n    const areSetsEqual = createIsCircular(config.areSetsEqual);\n\n    config = Object.assign({}, config, {\n      areArraysEqual,\n      areMapsEqual,\n      areObjectsEqual,\n      areSetsEqual,\n    });\n  }\n\n  return config;\n}\n\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nexport function createInternalEqualityComparator<Meta>(\n  compare: EqualityComparator<Meta>,\n): InternalEqualityComparator<Meta> {\n  return function (\n    a: any,\n    b: any,\n    _indexOrKeyA: any,\n    _indexOrKeyB: any,\n    _parentA: any,\n    _parentB: any,\n    state: State<Meta>,\n  ) {\n    return compare(a, b, state);\n  };\n}\n\n/**\n * Create the `isEqual` function used by the consuming application.\n */\nexport function createIsEqual<Meta>({ circular, comparator, createState, equals, strict }: CreateIsEqualOptions<Meta>) {\n  if (createState) {\n    return function isEqual<A, B>(a: A, b: B): boolean {\n      const { cache = circular ? new WeakMap() : undefined, meta } = createState();\n\n      return comparator(a, b, {\n        cache,\n        equals,\n        meta,\n        strict,\n      } as State<Meta>);\n    };\n  }\n\n  if (circular) {\n    return function isEqual<A, B>(a: A, b: B): boolean {\n      return comparator(a, b, {\n        cache: new WeakMap(),\n        equals,\n        meta: undefined as Meta,\n        strict,\n      } as State<Meta>);\n    };\n  }\n\n  const state = {\n    cache: undefined,\n    equals,\n    meta: undefined,\n    strict,\n  } as State<Meta>;\n\n  return function isEqual<A, B>(a: A, b: B): boolean {\n    return comparator(a, b, state);\n  };\n}\n", "import {\n  createEqualityComparatorConfig,\n  createEqualityComparator,\n  createInternalEqualityComparator,\n  createIsEqual,\n} from './comparator.js';\nimport type { CustomEqualCreatorOptions } from './internalTypes.js';\nimport { sameValueZeroEqual } from './utils.js';\n\nexport { sameValueZeroEqual };\nexport type {\n  AnyEqualityComparator,\n  Cache,\n  CircularState,\n  ComparatorConfig,\n  CreateCustomComparatorConfig,\n  CreateState,\n  CustomEqualCreatorOptions,\n  DefaultState,\n  Dictionary,\n  EqualityComparator,\n  EqualityComparatorCreator,\n  InternalEqualityComparator,\n  PrimitiveWrapper,\n  State,\n  TypeEqualityComparator,\n  TypedArray,\n} from './internalTypes.js';\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nexport const deepEqual = createCustomEqual();\n\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */\nexport const strictDeepEqual = createCustomEqual({ strict: true });\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nexport const circularDeepEqual = createCustomEqual({ circular: true });\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */\nexport const strictCircularDeepEqual = createCustomEqual({\n  circular: true,\n  strict: true,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nexport const shallowEqual = createCustomEqual({\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */\nexport const strictShallowEqual = createCustomEqual({\n  strict: true,\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nexport const circularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */\nexport const strictCircularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n  strict: true,\n});\n\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nexport function createCustomEqual<Meta = undefined>(options: CustomEqualCreatorOptions<Meta> = {}) {\n  const {\n    circular = false,\n    createInternalComparator: createCustomInternalComparator,\n    createState,\n    strict = false,\n  } = options;\n\n  const config = createEqualityComparatorConfig<Meta>(options);\n  const comparator = createEqualityComparator(config);\n  const equals = createCustomInternalComparator\n    ? createCustomInternalComparator(comparator)\n    : createInternalEqualityComparator(comparator);\n\n  return createIsEqual({ circular, comparator, createState, equals, strict });\n}\n", "/**\r\n * Custom positioning reference element.\r\n * @see https://floating-ui.com/docs/virtual-elements\r\n */\r\n\r\nconst sides = ['top', 'right', 'bottom', 'left'];\r\nconst alignments = ['start', 'end'];\r\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\r\nconst min = Math.min;\r\nconst max = Math.max;\r\nconst round = Math.round;\r\nconst floor = Math.floor;\r\nconst createCoords = v => ({\r\n  x: v,\r\n  y: v\r\n});\r\nconst oppositeSideMap = {\r\n  left: 'right',\r\n  right: 'left',\r\n  bottom: 'top',\r\n  top: 'bottom'\r\n};\r\nconst oppositeAlignmentMap = {\r\n  start: 'end',\r\n  end: 'start'\r\n};\r\nfunction clamp(start, value, end) {\r\n  return max(start, min(value, end));\r\n}\r\nfunction evaluate(value, param) {\r\n  return typeof value === 'function' ? value(param) : value;\r\n}\r\nfunction getSide(placement) {\r\n  return placement.split('-')[0];\r\n}\r\nfunction getAlignment(placement) {\r\n  return placement.split('-')[1];\r\n}\r\nfunction getOppositeAxis(axis) {\r\n  return axis === 'x' ? 'y' : 'x';\r\n}\r\nfunction getAxisLength(axis) {\r\n  return axis === 'y' ? 'height' : 'width';\r\n}\r\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\r\nfunction getSideAxis(placement) {\r\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\r\n}\r\nfunction getAlignmentAxis(placement) {\r\n  return getOppositeAxis(getSideAxis(placement));\r\n}\r\nfunction getAlignmentSides(placement, rects, rtl) {\r\n  if (rtl === void 0) {\r\n    rtl = false;\r\n  }\r\n  const alignment = getAlignment(placement);\r\n  const alignmentAxis = getAlignmentAxis(placement);\r\n  const length = getAxisLength(alignmentAxis);\r\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\r\n  if (rects.reference[length] > rects.floating[length]) {\r\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\r\n  }\r\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\r\n}\r\nfunction getExpandedPlacements(placement) {\r\n  const oppositePlacement = getOppositePlacement(placement);\r\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\r\n}\r\nfunction getOppositeAlignmentPlacement(placement) {\r\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\r\n}\r\nconst lrPlacement = ['left', 'right'];\r\nconst rlPlacement = ['right', 'left'];\r\nconst tbPlacement = ['top', 'bottom'];\r\nconst btPlacement = ['bottom', 'top'];\r\nfunction getSideList(side, isStart, rtl) {\r\n  switch (side) {\r\n    case 'top':\r\n    case 'bottom':\r\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\r\n      return isStart ? lrPlacement : rlPlacement;\r\n    case 'left':\r\n    case 'right':\r\n      return isStart ? tbPlacement : btPlacement;\r\n    default:\r\n      return [];\r\n  }\r\n}\r\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\r\n  const alignment = getAlignment(placement);\r\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\r\n  if (alignment) {\r\n    list = list.map(side => side + \"-\" + alignment);\r\n    if (flipAlignment) {\r\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\r\n    }\r\n  }\r\n  return list;\r\n}\r\nfunction getOppositePlacement(placement) {\r\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\r\n}\r\nfunction expandPaddingObject(padding) {\r\n  return {\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    left: 0,\r\n    ...padding\r\n  };\r\n}\r\nfunction getPaddingObject(padding) {\r\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\r\n    top: padding,\r\n    right: padding,\r\n    bottom: padding,\r\n    left: padding\r\n  };\r\n}\r\nfunction rectToClientRect(rect) {\r\n  const {\r\n    x,\r\n    y,\r\n    width,\r\n    height\r\n  } = rect;\r\n  return {\r\n    width,\r\n    height,\r\n    top: y,\r\n    left: x,\r\n    right: x + width,\r\n    bottom: y + height,\r\n    x,\r\n    y\r\n  };\r\n}\r\n\r\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\r\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\r\nexport { rectToClientRect } from '@floating-ui/utils';\r\n\r\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\r\n  let {\r\n    reference,\r\n    floating\r\n  } = _ref;\r\n  const sideAxis = getSideAxis(placement);\r\n  const alignmentAxis = getAlignmentAxis(placement);\r\n  const alignLength = getAxisLength(alignmentAxis);\r\n  const side = getSide(placement);\r\n  const isVertical = sideAxis === 'y';\r\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\r\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\r\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\r\n  let coords;\r\n  switch (side) {\r\n    case 'top':\r\n      coords = {\r\n        x: commonX,\r\n        y: reference.y - floating.height\r\n      };\r\n      break;\r\n    case 'bottom':\r\n      coords = {\r\n        x: commonX,\r\n        y: reference.y + reference.height\r\n      };\r\n      break;\r\n    case 'right':\r\n      coords = {\r\n        x: reference.x + reference.width,\r\n        y: commonY\r\n      };\r\n      break;\r\n    case 'left':\r\n      coords = {\r\n        x: reference.x - floating.width,\r\n        y: commonY\r\n      };\r\n      break;\r\n    default:\r\n      coords = {\r\n        x: reference.x,\r\n        y: reference.y\r\n      };\r\n  }\r\n  switch (getAlignment(placement)) {\r\n    case 'start':\r\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\r\n      break;\r\n    case 'end':\r\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\r\n      break;\r\n  }\r\n  return coords;\r\n}\r\n\r\n/**\r\n * Resolves with an object of overflow side offsets that determine how much the\r\n * element is overflowing a given clipping boundary on each side.\r\n * - positive = overflowing the boundary by that number of pixels\r\n * - negative = how many pixels left before it will overflow\r\n * - 0 = lies flush with the boundary\r\n * @see https://floating-ui.com/docs/detectOverflow\r\n */\r\nasync function detectOverflow(state, options) {\r\n  var _await$platform$isEle;\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  const {\r\n    x,\r\n    y,\r\n    platform,\r\n    rects,\r\n    elements,\r\n    strategy\r\n  } = state;\r\n  const {\r\n    boundary = 'clippingAncestors',\r\n    rootBoundary = 'viewport',\r\n    elementContext = 'floating',\r\n    altBoundary = false,\r\n    padding = 0\r\n  } = evaluate(options, state);\r\n  const paddingObject = getPaddingObject(padding);\r\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\r\n  const element = elements[altBoundary ? altContext : elementContext];\r\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\r\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\r\n    boundary,\r\n    rootBoundary,\r\n    strategy\r\n  }));\r\n  const rect = elementContext === 'floating' ? {\r\n    x,\r\n    y,\r\n    width: rects.floating.width,\r\n    height: rects.floating.height\r\n  } : rects.reference;\r\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\r\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\r\n    x: 1,\r\n    y: 1\r\n  } : {\r\n    x: 1,\r\n    y: 1\r\n  };\r\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\r\n    elements,\r\n    rect,\r\n    offsetParent,\r\n    strategy\r\n  }) : rect);\r\n  return {\r\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\r\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\r\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\r\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\r\n  };\r\n}\r\n\r\n/**\r\n * Computes the `x` and `y` coordinates that will place the floating element\r\n * next to a given reference element.\r\n *\r\n * This export does not have any `platform` interface logic. You will need to\r\n * write one for the platform you are using Floating UI with.\r\n */\r\nconst computePosition = async (reference, floating, config) => {\r\n  const {\r\n    placement = 'bottom',\r\n    strategy = 'absolute',\r\n    middleware = [],\r\n    platform\r\n  } = config;\r\n  const validMiddleware = middleware.filter(Boolean);\r\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\r\n  let rects = await platform.getElementRects({\r\n    reference,\r\n    floating,\r\n    strategy\r\n  });\r\n  let {\r\n    x,\r\n    y\r\n  } = computeCoordsFromPlacement(rects, placement, rtl);\r\n  let statefulPlacement = placement;\r\n  let middlewareData = {};\r\n  let resetCount = 0;\r\n  for (let i = 0; i < validMiddleware.length; i++) {\r\n    var _platform$detectOverf;\r\n    const {\r\n      name,\r\n      fn\r\n    } = validMiddleware[i];\r\n    const {\r\n      x: nextX,\r\n      y: nextY,\r\n      data,\r\n      reset\r\n    } = await fn({\r\n      x,\r\n      y,\r\n      initialPlacement: placement,\r\n      placement: statefulPlacement,\r\n      strategy,\r\n      middlewareData,\r\n      rects,\r\n      platform: {\r\n        ...platform,\r\n        detectOverflow: (_platform$detectOverf = platform.detectOverflow) != null ? _platform$detectOverf : detectOverflow\r\n      },\r\n      elements: {\r\n        reference,\r\n        floating\r\n      }\r\n    });\r\n    x = nextX != null ? nextX : x;\r\n    y = nextY != null ? nextY : y;\r\n    middlewareData = {\r\n      ...middlewareData,\r\n      [name]: {\r\n        ...middlewareData[name],\r\n        ...data\r\n      }\r\n    };\r\n    if (reset && resetCount <= 50) {\r\n      resetCount++;\r\n      if (typeof reset === 'object') {\r\n        if (reset.placement) {\r\n          statefulPlacement = reset.placement;\r\n        }\r\n        if (reset.rects) {\r\n          rects = reset.rects === true ? await platform.getElementRects({\r\n            reference,\r\n            floating,\r\n            strategy\r\n          }) : reset.rects;\r\n        }\r\n        ({\r\n          x,\r\n          y\r\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\r\n      }\r\n      i = -1;\r\n    }\r\n  }\r\n  return {\r\n    x,\r\n    y,\r\n    placement: statefulPlacement,\r\n    strategy,\r\n    middlewareData\r\n  };\r\n};\r\n\r\n/**\r\n * Provides data to position an inner element of the floating element so that it\r\n * appears centered to the reference element.\r\n * @see https://floating-ui.com/docs/arrow\r\n */\r\nconst arrow = options => ({\r\n  name: 'arrow',\r\n  options,\r\n  async fn(state) {\r\n    const {\r\n      x,\r\n      y,\r\n      placement,\r\n      rects,\r\n      platform,\r\n      elements,\r\n      middlewareData\r\n    } = state;\r\n    // Since `element` is required, we don't Partial<> the type.\r\n    const {\r\n      element,\r\n      padding = 0\r\n    } = evaluate(options, state) || {};\r\n    if (element == null) {\r\n      return {};\r\n    }\r\n    const paddingObject = getPaddingObject(padding);\r\n    const coords = {\r\n      x,\r\n      y\r\n    };\r\n    const axis = getAlignmentAxis(placement);\r\n    const length = getAxisLength(axis);\r\n    const arrowDimensions = await platform.getDimensions(element);\r\n    const isYAxis = axis === 'y';\r\n    const minProp = isYAxis ? 'top' : 'left';\r\n    const maxProp = isYAxis ? 'bottom' : 'right';\r\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\r\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\r\n    const startDiff = coords[axis] - rects.reference[axis];\r\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\r\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\r\n\r\n    // DOM platform can return `window` as the `offsetParent`.\r\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\r\n      clientSize = elements.floating[clientProp] || rects.floating[length];\r\n    }\r\n    const centerToReference = endDiff / 2 - startDiff / 2;\r\n\r\n    // If the padding is large enough that it causes the arrow to no longer be\r\n    // centered, modify the padding so that it is centered.\r\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\r\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\r\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\r\n\r\n    // Make sure the arrow doesn't overflow the floating element if the center\r\n    // point is outside the floating element's bounds.\r\n    const min$1 = minPadding;\r\n    const max = clientSize - arrowDimensions[length] - maxPadding;\r\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\r\n    const offset = clamp(min$1, center, max);\r\n\r\n    // If the reference is small enough that the arrow's padding causes it to\r\n    // to point to nothing for an aligned placement, adjust the offset of the\r\n    // floating element itself. To ensure `shift()` continues to take action,\r\n    // a single reset is performed when this is true.\r\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\r\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\r\n    return {\r\n      [axis]: coords[axis] + alignmentOffset,\r\n      data: {\r\n        [axis]: offset,\r\n        centerOffset: center - offset - alignmentOffset,\r\n        ...(shouldAddOffset && {\r\n          alignmentOffset\r\n        })\r\n      },\r\n      reset: shouldAddOffset\r\n    };\r\n  }\r\n});\r\n\r\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\r\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\r\n  return allowedPlacementsSortedByAlignment.filter(placement => {\r\n    if (alignment) {\r\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\r\n    }\r\n    return true;\r\n  });\r\n}\r\n/**\r\n * Optimizes the visibility of the floating element by choosing the placement\r\n * that has the most space available automatically, without needing to specify a\r\n * preferred placement. Alternative to `flip`.\r\n * @see https://floating-ui.com/docs/autoPlacement\r\n */\r\nconst autoPlacement = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'autoPlacement',\r\n    options,\r\n    async fn(state) {\r\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\r\n      const {\r\n        rects,\r\n        middlewareData,\r\n        placement,\r\n        platform,\r\n        elements\r\n      } = state;\r\n      const {\r\n        crossAxis = false,\r\n        alignment,\r\n        allowedPlacements = placements,\r\n        autoAlignment = true,\r\n        ...detectOverflowOptions\r\n      } = evaluate(options, state);\r\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\r\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\r\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\r\n      const currentPlacement = placements$1[currentIndex];\r\n      if (currentPlacement == null) {\r\n        return {};\r\n      }\r\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\r\n\r\n      // Make `computeCoords` start from the right place.\r\n      if (placement !== currentPlacement) {\r\n        return {\r\n          reset: {\r\n            placement: placements$1[0]\r\n          }\r\n        };\r\n      }\r\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\r\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\r\n        placement: currentPlacement,\r\n        overflows: currentOverflows\r\n      }];\r\n      const nextPlacement = placements$1[currentIndex + 1];\r\n\r\n      // There are more placements to check.\r\n      if (nextPlacement) {\r\n        return {\r\n          data: {\r\n            index: currentIndex + 1,\r\n            overflows: allOverflows\r\n          },\r\n          reset: {\r\n            placement: nextPlacement\r\n          }\r\n        };\r\n      }\r\n      const placementsSortedByMostSpace = allOverflows.map(d => {\r\n        const alignment = getAlignment(d.placement);\r\n        return [d.placement, alignment && crossAxis ?\r\n        // Check along the mainAxis and main crossAxis side.\r\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\r\n        // Check only the mainAxis.\r\n        d.overflows[0], d.overflows];\r\n      }).sort((a, b) => a[1] - b[1]);\r\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\r\n      // Aligned placements should not check their opposite crossAxis\r\n      // side.\r\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\r\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\r\n      if (resetPlacement !== placement) {\r\n        return {\r\n          data: {\r\n            index: currentIndex + 1,\r\n            overflows: allOverflows\r\n          },\r\n          reset: {\r\n            placement: resetPlacement\r\n          }\r\n        };\r\n      }\r\n      return {};\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by flipping the `placement`\r\n * in order to keep it in view when the preferred placement(s) will overflow the\r\n * clipping boundary. Alternative to `autoPlacement`.\r\n * @see https://floating-ui.com/docs/flip\r\n */\r\nconst flip = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'flip',\r\n    options,\r\n    async fn(state) {\r\n      var _middlewareData$arrow, _middlewareData$flip;\r\n      const {\r\n        placement,\r\n        middlewareData,\r\n        rects,\r\n        initialPlacement,\r\n        platform,\r\n        elements\r\n      } = state;\r\n      const {\r\n        mainAxis: checkMainAxis = true,\r\n        crossAxis: checkCrossAxis = true,\r\n        fallbackPlacements: specifiedFallbackPlacements,\r\n        fallbackStrategy = 'bestFit',\r\n        fallbackAxisSideDirection = 'none',\r\n        flipAlignment = true,\r\n        ...detectOverflowOptions\r\n      } = evaluate(options, state);\r\n\r\n      // If a reset by the arrow was caused due to an alignment offset being\r\n      // added, we should skip any logic now since `flip()` has already done its\r\n      // work.\r\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\r\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\r\n        return {};\r\n      }\r\n      const side = getSide(placement);\r\n      const initialSideAxis = getSideAxis(initialPlacement);\r\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\r\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\r\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\r\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\r\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\r\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\r\n      }\r\n      const placements = [initialPlacement, ...fallbackPlacements];\r\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\r\n      const overflows = [];\r\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\r\n      if (checkMainAxis) {\r\n        overflows.push(overflow[side]);\r\n      }\r\n      if (checkCrossAxis) {\r\n        const sides = getAlignmentSides(placement, rects, rtl);\r\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\r\n      }\r\n      overflowsData = [...overflowsData, {\r\n        placement,\r\n        overflows\r\n      }];\r\n\r\n      // One or more sides is overflowing.\r\n      if (!overflows.every(side => side <= 0)) {\r\n        var _middlewareData$flip2, _overflowsData$filter;\r\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\r\n        const nextPlacement = placements[nextIndex];\r\n        if (nextPlacement) {\r\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\r\n          if (!ignoreCrossAxisOverflow ||\r\n          // We leave the current main axis only if every placement on that axis\r\n          // overflows the main axis.\r\n          overflowsData.every(d => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\r\n            // Try next placement and re-run the lifecycle.\r\n            return {\r\n              data: {\r\n                index: nextIndex,\r\n                overflows: overflowsData\r\n              },\r\n              reset: {\r\n                placement: nextPlacement\r\n              }\r\n            };\r\n          }\r\n        }\r\n\r\n        // First, find the candidates that fit on the mainAxis side of overflow,\r\n        // then find the placement that fits the best on the main crossAxis side.\r\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\r\n\r\n        // Otherwise fallback.\r\n        if (!resetPlacement) {\r\n          switch (fallbackStrategy) {\r\n            case 'bestFit':\r\n              {\r\n                var _overflowsData$filter2;\r\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\r\n                  if (hasFallbackAxisSideDirection) {\r\n                    const currentSideAxis = getSideAxis(d.placement);\r\n                    return currentSideAxis === initialSideAxis ||\r\n                    // Create a bias to the `y` side axis due to horizontal\r\n                    // reading directions favoring greater width.\r\n                    currentSideAxis === 'y';\r\n                  }\r\n                  return true;\r\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\r\n                if (placement) {\r\n                  resetPlacement = placement;\r\n                }\r\n                break;\r\n              }\r\n            case 'initialPlacement':\r\n              resetPlacement = initialPlacement;\r\n              break;\r\n          }\r\n        }\r\n        if (placement !== resetPlacement) {\r\n          return {\r\n            reset: {\r\n              placement: resetPlacement\r\n            }\r\n          };\r\n        }\r\n      }\r\n      return {};\r\n    }\r\n  };\r\n};\r\n\r\nfunction getSideOffsets(overflow, rect) {\r\n  return {\r\n    top: overflow.top - rect.height,\r\n    right: overflow.right - rect.width,\r\n    bottom: overflow.bottom - rect.height,\r\n    left: overflow.left - rect.width\r\n  };\r\n}\r\nfunction isAnySideFullyClipped(overflow) {\r\n  return sides.some(side => overflow[side] >= 0);\r\n}\r\n/**\r\n * Provides data to hide the floating element in applicable situations, such as\r\n * when it is not in the same clipping context as the reference element.\r\n * @see https://floating-ui.com/docs/hide\r\n */\r\nconst hide = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'hide',\r\n    options,\r\n    async fn(state) {\r\n      const {\r\n        rects,\r\n        platform\r\n      } = state;\r\n      const {\r\n        strategy = 'referenceHidden',\r\n        ...detectOverflowOptions\r\n      } = evaluate(options, state);\r\n      switch (strategy) {\r\n        case 'referenceHidden':\r\n          {\r\n            const overflow = await platform.detectOverflow(state, {\r\n              ...detectOverflowOptions,\r\n              elementContext: 'reference'\r\n            });\r\n            const offsets = getSideOffsets(overflow, rects.reference);\r\n            return {\r\n              data: {\r\n                referenceHiddenOffsets: offsets,\r\n                referenceHidden: isAnySideFullyClipped(offsets)\r\n              }\r\n            };\r\n          }\r\n        case 'escaped':\r\n          {\r\n            const overflow = await platform.detectOverflow(state, {\r\n              ...detectOverflowOptions,\r\n              altBoundary: true\r\n            });\r\n            const offsets = getSideOffsets(overflow, rects.floating);\r\n            return {\r\n              data: {\r\n                escapedOffsets: offsets,\r\n                escaped: isAnySideFullyClipped(offsets)\r\n              }\r\n            };\r\n          }\r\n        default:\r\n          {\r\n            return {};\r\n          }\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\nfunction getBoundingRect(rects) {\r\n  const minX = min(...rects.map(rect => rect.left));\r\n  const minY = min(...rects.map(rect => rect.top));\r\n  const maxX = max(...rects.map(rect => rect.right));\r\n  const maxY = max(...rects.map(rect => rect.bottom));\r\n  return {\r\n    x: minX,\r\n    y: minY,\r\n    width: maxX - minX,\r\n    height: maxY - minY\r\n  };\r\n}\r\nfunction getRectsByLine(rects) {\r\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\r\n  const groups = [];\r\n  let prevRect = null;\r\n  for (let i = 0; i < sortedRects.length; i++) {\r\n    const rect = sortedRects[i];\r\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\r\n      groups.push([rect]);\r\n    } else {\r\n      groups[groups.length - 1].push(rect);\r\n    }\r\n    prevRect = rect;\r\n  }\r\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\r\n}\r\n/**\r\n * Provides improved positioning for inline reference elements that can span\r\n * over multiple lines, such as hyperlinks or range selections.\r\n * @see https://floating-ui.com/docs/inline\r\n */\r\nconst inline = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'inline',\r\n    options,\r\n    async fn(state) {\r\n      const {\r\n        placement,\r\n        elements,\r\n        rects,\r\n        platform,\r\n        strategy\r\n      } = state;\r\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\r\n      // ClientRect's bounds, despite the event listener being triggered. A\r\n      // padding of 2 seems to handle this issue.\r\n      const {\r\n        padding = 2,\r\n        x,\r\n        y\r\n      } = evaluate(options, state);\r\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\r\n      const clientRects = getRectsByLine(nativeClientRects);\r\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\r\n      const paddingObject = getPaddingObject(padding);\r\n      function getBoundingClientRect() {\r\n        // There are two rects and they are disjoined.\r\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\r\n          // Find the first rect in which the point is fully inside.\r\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\r\n        }\r\n\r\n        // There are 2 or more connected rects.\r\n        if (clientRects.length >= 2) {\r\n          if (getSideAxis(placement) === 'y') {\r\n            const firstRect = clientRects[0];\r\n            const lastRect = clientRects[clientRects.length - 1];\r\n            const isTop = getSide(placement) === 'top';\r\n            const top = firstRect.top;\r\n            const bottom = lastRect.bottom;\r\n            const left = isTop ? firstRect.left : lastRect.left;\r\n            const right = isTop ? firstRect.right : lastRect.right;\r\n            const width = right - left;\r\n            const height = bottom - top;\r\n            return {\r\n              top,\r\n              bottom,\r\n              left,\r\n              right,\r\n              width,\r\n              height,\r\n              x: left,\r\n              y: top\r\n            };\r\n          }\r\n          const isLeftSide = getSide(placement) === 'left';\r\n          const maxRight = max(...clientRects.map(rect => rect.right));\r\n          const minLeft = min(...clientRects.map(rect => rect.left));\r\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\r\n          const top = measureRects[0].top;\r\n          const bottom = measureRects[measureRects.length - 1].bottom;\r\n          const left = minLeft;\r\n          const right = maxRight;\r\n          const width = right - left;\r\n          const height = bottom - top;\r\n          return {\r\n            top,\r\n            bottom,\r\n            left,\r\n            right,\r\n            width,\r\n            height,\r\n            x: left,\r\n            y: top\r\n          };\r\n        }\r\n        return fallback;\r\n      }\r\n      const resetRects = await platform.getElementRects({\r\n        reference: {\r\n          getBoundingClientRect\r\n        },\r\n        floating: elements.floating,\r\n        strategy\r\n      });\r\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\r\n        return {\r\n          reset: {\r\n            rects: resetRects\r\n          }\r\n        };\r\n      }\r\n      return {};\r\n    }\r\n  };\r\n};\r\n\r\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\r\n\r\n// For type backwards-compatibility, the `OffsetOptions` type was also\r\n// Derivable.\r\n\r\nasync function convertValueToCoords(state, options) {\r\n  const {\r\n    placement,\r\n    platform,\r\n    elements\r\n  } = state;\r\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\r\n  const side = getSide(placement);\r\n  const alignment = getAlignment(placement);\r\n  const isVertical = getSideAxis(placement) === 'y';\r\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\r\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\r\n  const rawValue = evaluate(options, state);\r\n\r\n  // eslint-disable-next-line prefer-const\r\n  let {\r\n    mainAxis,\r\n    crossAxis,\r\n    alignmentAxis\r\n  } = typeof rawValue === 'number' ? {\r\n    mainAxis: rawValue,\r\n    crossAxis: 0,\r\n    alignmentAxis: null\r\n  } : {\r\n    mainAxis: rawValue.mainAxis || 0,\r\n    crossAxis: rawValue.crossAxis || 0,\r\n    alignmentAxis: rawValue.alignmentAxis\r\n  };\r\n  if (alignment && typeof alignmentAxis === 'number') {\r\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\r\n  }\r\n  return isVertical ? {\r\n    x: crossAxis * crossAxisMulti,\r\n    y: mainAxis * mainAxisMulti\r\n  } : {\r\n    x: mainAxis * mainAxisMulti,\r\n    y: crossAxis * crossAxisMulti\r\n  };\r\n}\r\n\r\n/**\r\n * Modifies the placement by translating the floating element along the\r\n * specified axes.\r\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\r\n * object may be passed.\r\n * @see https://floating-ui.com/docs/offset\r\n */\r\nconst offset = function (options) {\r\n  if (options === void 0) {\r\n    options = 0;\r\n  }\r\n  return {\r\n    name: 'offset',\r\n    options,\r\n    async fn(state) {\r\n      var _middlewareData$offse, _middlewareData$arrow;\r\n      const {\r\n        x,\r\n        y,\r\n        placement,\r\n        middlewareData\r\n      } = state;\r\n      const diffCoords = await convertValueToCoords(state, options);\r\n\r\n      // If the placement is the same and the arrow caused an alignment offset\r\n      // then we don't need to change the positioning coordinates.\r\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\r\n        return {};\r\n      }\r\n      return {\r\n        x: x + diffCoords.x,\r\n        y: y + diffCoords.y,\r\n        data: {\r\n          ...diffCoords,\r\n          placement\r\n        }\r\n      };\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by shifting it in order to\r\n * keep it in view when it will overflow the clipping boundary.\r\n * @see https://floating-ui.com/docs/shift\r\n */\r\nconst shift = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'shift',\r\n    options,\r\n    async fn(state) {\r\n      const {\r\n        x,\r\n        y,\r\n        placement,\r\n        platform\r\n      } = state;\r\n      const {\r\n        mainAxis: checkMainAxis = true,\r\n        crossAxis: checkCrossAxis = false,\r\n        limiter = {\r\n          fn: _ref => {\r\n            let {\r\n              x,\r\n              y\r\n            } = _ref;\r\n            return {\r\n              x,\r\n              y\r\n            };\r\n          }\r\n        },\r\n        ...detectOverflowOptions\r\n      } = evaluate(options, state);\r\n      const coords = {\r\n        x,\r\n        y\r\n      };\r\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\r\n      const crossAxis = getSideAxis(getSide(placement));\r\n      const mainAxis = getOppositeAxis(crossAxis);\r\n      let mainAxisCoord = coords[mainAxis];\r\n      let crossAxisCoord = coords[crossAxis];\r\n      if (checkMainAxis) {\r\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\r\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\r\n        const min = mainAxisCoord + overflow[minSide];\r\n        const max = mainAxisCoord - overflow[maxSide];\r\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\r\n      }\r\n      if (checkCrossAxis) {\r\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\r\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\r\n        const min = crossAxisCoord + overflow[minSide];\r\n        const max = crossAxisCoord - overflow[maxSide];\r\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\r\n      }\r\n      const limitedCoords = limiter.fn({\r\n        ...state,\r\n        [mainAxis]: mainAxisCoord,\r\n        [crossAxis]: crossAxisCoord\r\n      });\r\n      return {\r\n        ...limitedCoords,\r\n        data: {\r\n          x: limitedCoords.x - x,\r\n          y: limitedCoords.y - y,\r\n          enabled: {\r\n            [mainAxis]: checkMainAxis,\r\n            [crossAxis]: checkCrossAxis\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n};\r\n/**\r\n * Built-in `limiter` that will stop `shift()` at a certain point.\r\n */\r\nconst limitShift = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    options,\r\n    fn(state) {\r\n      const {\r\n        x,\r\n        y,\r\n        placement,\r\n        rects,\r\n        middlewareData\r\n      } = state;\r\n      const {\r\n        offset = 0,\r\n        mainAxis: checkMainAxis = true,\r\n        crossAxis: checkCrossAxis = true\r\n      } = evaluate(options, state);\r\n      const coords = {\r\n        x,\r\n        y\r\n      };\r\n      const crossAxis = getSideAxis(placement);\r\n      const mainAxis = getOppositeAxis(crossAxis);\r\n      let mainAxisCoord = coords[mainAxis];\r\n      let crossAxisCoord = coords[crossAxis];\r\n      const rawOffset = evaluate(offset, state);\r\n      const computedOffset = typeof rawOffset === 'number' ? {\r\n        mainAxis: rawOffset,\r\n        crossAxis: 0\r\n      } : {\r\n        mainAxis: 0,\r\n        crossAxis: 0,\r\n        ...rawOffset\r\n      };\r\n      if (checkMainAxis) {\r\n        const len = mainAxis === 'y' ? 'height' : 'width';\r\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\r\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\r\n        if (mainAxisCoord < limitMin) {\r\n          mainAxisCoord = limitMin;\r\n        } else if (mainAxisCoord > limitMax) {\r\n          mainAxisCoord = limitMax;\r\n        }\r\n      }\r\n      if (checkCrossAxis) {\r\n        var _middlewareData$offse, _middlewareData$offse2;\r\n        const len = mainAxis === 'y' ? 'width' : 'height';\r\n        const isOriginSide = originSides.has(getSide(placement));\r\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\r\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\r\n        if (crossAxisCoord < limitMin) {\r\n          crossAxisCoord = limitMin;\r\n        } else if (crossAxisCoord > limitMax) {\r\n          crossAxisCoord = limitMax;\r\n        }\r\n      }\r\n      return {\r\n        [mainAxis]: mainAxisCoord,\r\n        [crossAxis]: crossAxisCoord\r\n      };\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Provides data that allows you to change the size of the floating element \r\n * for instance, prevent it from overflowing the clipping boundary or match the\r\n * width of the reference element.\r\n * @see https://floating-ui.com/docs/size\r\n */\r\nconst size = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'size',\r\n    options,\r\n    async fn(state) {\r\n      var _state$middlewareData, _state$middlewareData2;\r\n      const {\r\n        placement,\r\n        rects,\r\n        platform,\r\n        elements\r\n      } = state;\r\n      const {\r\n        apply = () => {},\r\n        ...detectOverflowOptions\r\n      } = evaluate(options, state);\r\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\r\n      const side = getSide(placement);\r\n      const alignment = getAlignment(placement);\r\n      const isYAxis = getSideAxis(placement) === 'y';\r\n      const {\r\n        width,\r\n        height\r\n      } = rects.floating;\r\n      let heightSide;\r\n      let widthSide;\r\n      if (side === 'top' || side === 'bottom') {\r\n        heightSide = side;\r\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\r\n      } else {\r\n        widthSide = side;\r\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\r\n      }\r\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\r\n      const maximumClippingWidth = width - overflow.left - overflow.right;\r\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\r\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\r\n      const noShift = !state.middlewareData.shift;\r\n      let availableHeight = overflowAvailableHeight;\r\n      let availableWidth = overflowAvailableWidth;\r\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\r\n        availableWidth = maximumClippingWidth;\r\n      }\r\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\r\n        availableHeight = maximumClippingHeight;\r\n      }\r\n      if (noShift && !alignment) {\r\n        const xMin = max(overflow.left, 0);\r\n        const xMax = max(overflow.right, 0);\r\n        const yMin = max(overflow.top, 0);\r\n        const yMax = max(overflow.bottom, 0);\r\n        if (isYAxis) {\r\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\r\n        } else {\r\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\r\n        }\r\n      }\r\n      await apply({\r\n        ...state,\r\n        availableWidth,\r\n        availableHeight\r\n      });\r\n      const nextDimensions = await platform.getDimensions(elements.floating);\r\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\r\n        return {\r\n          reset: {\r\n            rects: true\r\n          }\r\n        };\r\n      }\r\n      return {};\r\n    }\r\n  };\r\n};\r\n\r\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\r\n", "function hasWindow() {\r\n  return typeof window !== 'undefined';\r\n}\r\nfunction getNodeName(node) {\r\n  if (isNode(node)) {\r\n    return (node.nodeName || '').toLowerCase();\r\n  }\r\n  // Mocked nodes in testing environments may not be instances of Node. By\r\n  // returning `#document` an infinite loop won't occur.\r\n  // https://github.com/floating-ui/floating-ui/issues/2317\r\n  return '#document';\r\n}\r\nfunction getWindow(node) {\r\n  var _node$ownerDocument;\r\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\r\n}\r\nfunction getDocumentElement(node) {\r\n  var _ref;\r\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\r\n}\r\nfunction isNode(value) {\r\n  if (!hasWindow()) {\r\n    return false;\r\n  }\r\n  return value instanceof Node || value instanceof getWindow(value).Node;\r\n}\r\nfunction isElement(value) {\r\n  if (!hasWindow()) {\r\n    return false;\r\n  }\r\n  return value instanceof Element || value instanceof getWindow(value).Element;\r\n}\r\nfunction isHTMLElement(value) {\r\n  if (!hasWindow()) {\r\n    return false;\r\n  }\r\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\r\n}\r\nfunction isShadowRoot(value) {\r\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\r\n    return false;\r\n  }\r\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\r\n}\r\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\r\nfunction isOverflowElement(element) {\r\n  const {\r\n    overflow,\r\n    overflowX,\r\n    overflowY,\r\n    display\r\n  } = getComputedStyle(element);\r\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\r\n}\r\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\r\nfunction isTableElement(element) {\r\n  return tableElements.has(getNodeName(element));\r\n}\r\nconst topLayerSelectors = [':popover-open', ':modal'];\r\nfunction isTopLayer(element) {\r\n  return topLayerSelectors.some(selector => {\r\n    try {\r\n      return element.matches(selector);\r\n    } catch (_e) {\r\n      return false;\r\n    }\r\n  });\r\n}\r\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\r\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\r\nconst containValues = ['paint', 'layout', 'strict', 'content'];\r\nfunction isContainingBlock(elementOrCss) {\r\n  const webkit = isWebKit();\r\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\r\n\r\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\r\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\r\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\r\n}\r\nfunction getContainingBlock(element) {\r\n  let currentNode = getParentNode(element);\r\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\r\n    if (isContainingBlock(currentNode)) {\r\n      return currentNode;\r\n    } else if (isTopLayer(currentNode)) {\r\n      return null;\r\n    }\r\n    currentNode = getParentNode(currentNode);\r\n  }\r\n  return null;\r\n}\r\nfunction isWebKit() {\r\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\r\n  return CSS.supports('-webkit-backdrop-filter', 'none');\r\n}\r\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\r\nfunction isLastTraversableNode(node) {\r\n  return lastTraversableNodeNames.has(getNodeName(node));\r\n}\r\nfunction getComputedStyle(element) {\r\n  return getWindow(element).getComputedStyle(element);\r\n}\r\nfunction getNodeScroll(element) {\r\n  if (isElement(element)) {\r\n    return {\r\n      scrollLeft: element.scrollLeft,\r\n      scrollTop: element.scrollTop\r\n    };\r\n  }\r\n  return {\r\n    scrollLeft: element.scrollX,\r\n    scrollTop: element.scrollY\r\n  };\r\n}\r\nfunction getParentNode(node) {\r\n  if (getNodeName(node) === 'html') {\r\n    return node;\r\n  }\r\n  const result =\r\n  // Step into the shadow DOM of the parent of a slotted node.\r\n  node.assignedSlot ||\r\n  // DOM Element detected.\r\n  node.parentNode ||\r\n  // ShadowRoot detected.\r\n  isShadowRoot(node) && node.host ||\r\n  // Fallback.\r\n  getDocumentElement(node);\r\n  return isShadowRoot(result) ? result.host : result;\r\n}\r\nfunction getNearestOverflowAncestor(node) {\r\n  const parentNode = getParentNode(node);\r\n  if (isLastTraversableNode(parentNode)) {\r\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\r\n  }\r\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\r\n    return parentNode;\r\n  }\r\n  return getNearestOverflowAncestor(parentNode);\r\n}\r\nfunction getOverflowAncestors(node, list, traverseIframes) {\r\n  var _node$ownerDocument2;\r\n  if (list === void 0) {\r\n    list = [];\r\n  }\r\n  if (traverseIframes === void 0) {\r\n    traverseIframes = true;\r\n  }\r\n  const scrollableAncestor = getNearestOverflowAncestor(node);\r\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\r\n  const win = getWindow(scrollableAncestor);\r\n  if (isBody) {\r\n    const frameElement = getFrameElement(win);\r\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\r\n  }\r\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\r\n}\r\nfunction getFrameElement(win) {\r\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\r\n}\r\n\r\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\r\n", "import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\r\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\r\nimport { getComputedStyle as getComputedStyle$1, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\r\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\r\n\r\nfunction getCssDimensions(element) {\r\n  const css = getComputedStyle$1(element);\r\n  // In testing environments, the `width` and `height` properties are empty\r\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\r\n  let width = parseFloat(css.width) || 0;\r\n  let height = parseFloat(css.height) || 0;\r\n  const hasOffset = isHTMLElement(element);\r\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\r\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\r\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\r\n  if (shouldFallback) {\r\n    width = offsetWidth;\r\n    height = offsetHeight;\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    $: shouldFallback\r\n  };\r\n}\r\n\r\nfunction unwrapElement(element) {\r\n  return !isElement(element) ? element.contextElement : element;\r\n}\r\n\r\nfunction getScale(element) {\r\n  const domElement = unwrapElement(element);\r\n  if (!isHTMLElement(domElement)) {\r\n    return createCoords(1);\r\n  }\r\n  const rect = domElement.getBoundingClientRect();\r\n  const {\r\n    width,\r\n    height,\r\n    $\r\n  } = getCssDimensions(domElement);\r\n  let x = ($ ? round(rect.width) : rect.width) / width;\r\n  let y = ($ ? round(rect.height) : rect.height) / height;\r\n\r\n  // 0, NaN, or Infinity should always fallback to 1.\r\n\r\n  if (!x || !Number.isFinite(x)) {\r\n    x = 1;\r\n  }\r\n  if (!y || !Number.isFinite(y)) {\r\n    y = 1;\r\n  }\r\n  return {\r\n    x,\r\n    y\r\n  };\r\n}\r\n\r\nconst noOffsets = /*#__PURE__*/createCoords(0);\r\nfunction getVisualOffsets(element) {\r\n  const win = getWindow(element);\r\n  if (!isWebKit() || !win.visualViewport) {\r\n    return noOffsets;\r\n  }\r\n  return {\r\n    x: win.visualViewport.offsetLeft,\r\n    y: win.visualViewport.offsetTop\r\n  };\r\n}\r\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\r\n  if (isFixed === void 0) {\r\n    isFixed = false;\r\n  }\r\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\r\n    return false;\r\n  }\r\n  return isFixed;\r\n}\r\n\r\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\r\n  if (includeScale === void 0) {\r\n    includeScale = false;\r\n  }\r\n  if (isFixedStrategy === void 0) {\r\n    isFixedStrategy = false;\r\n  }\r\n  const clientRect = element.getBoundingClientRect();\r\n  const domElement = unwrapElement(element);\r\n  let scale = createCoords(1);\r\n  if (includeScale) {\r\n    if (offsetParent) {\r\n      if (isElement(offsetParent)) {\r\n        scale = getScale(offsetParent);\r\n      }\r\n    } else {\r\n      scale = getScale(element);\r\n    }\r\n  }\r\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\r\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\r\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\r\n  let width = clientRect.width / scale.x;\r\n  let height = clientRect.height / scale.y;\r\n  if (domElement) {\r\n    const win = getWindow(domElement);\r\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\r\n    let currentWin = win;\r\n    let currentIFrame = getFrameElement(currentWin);\r\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\r\n      const iframeScale = getScale(currentIFrame);\r\n      const iframeRect = currentIFrame.getBoundingClientRect();\r\n      const css = getComputedStyle$1(currentIFrame);\r\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\r\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\r\n      x *= iframeScale.x;\r\n      y *= iframeScale.y;\r\n      width *= iframeScale.x;\r\n      height *= iframeScale.y;\r\n      x += left;\r\n      y += top;\r\n      currentWin = getWindow(currentIFrame);\r\n      currentIFrame = getFrameElement(currentWin);\r\n    }\r\n  }\r\n  return rectToClientRect({\r\n    width,\r\n    height,\r\n    x,\r\n    y\r\n  });\r\n}\r\n\r\n// If <html> has a CSS width greater than the viewport, then this will be\r\n// incorrect for RTL.\r\nfunction getWindowScrollBarX(element, rect) {\r\n  const leftScroll = getNodeScroll(element).scrollLeft;\r\n  if (!rect) {\r\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\r\n  }\r\n  return rect.left + leftScroll;\r\n}\r\n\r\nfunction getHTMLOffset(documentElement, scroll) {\r\n  const htmlRect = documentElement.getBoundingClientRect();\r\n  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);\r\n  const y = htmlRect.top + scroll.scrollTop;\r\n  return {\r\n    x,\r\n    y\r\n  };\r\n}\r\n\r\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\r\n  let {\r\n    elements,\r\n    rect,\r\n    offsetParent,\r\n    strategy\r\n  } = _ref;\r\n  const isFixed = strategy === 'fixed';\r\n  const documentElement = getDocumentElement(offsetParent);\r\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\r\n  if (offsetParent === documentElement || topLayer && isFixed) {\r\n    return rect;\r\n  }\r\n  let scroll = {\r\n    scrollLeft: 0,\r\n    scrollTop: 0\r\n  };\r\n  let scale = createCoords(1);\r\n  const offsets = createCoords(0);\r\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\r\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\r\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\r\n      scroll = getNodeScroll(offsetParent);\r\n    }\r\n    if (isHTMLElement(offsetParent)) {\r\n      const offsetRect = getBoundingClientRect(offsetParent);\r\n      scale = getScale(offsetParent);\r\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\r\n      offsets.y = offsetRect.y + offsetParent.clientTop;\r\n    }\r\n  }\r\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\r\n  return {\r\n    width: rect.width * scale.x,\r\n    height: rect.height * scale.y,\r\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\r\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\r\n  };\r\n}\r\n\r\nfunction getClientRects(element) {\r\n  return Array.from(element.getClientRects());\r\n}\r\n\r\n// Gets the entire size of the scrollable document area, even extending outside\r\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\r\nfunction getDocumentRect(element) {\r\n  const html = getDocumentElement(element);\r\n  const scroll = getNodeScroll(element);\r\n  const body = element.ownerDocument.body;\r\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\r\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\r\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\r\n  const y = -scroll.scrollTop;\r\n  if (getComputedStyle$1(body).direction === 'rtl') {\r\n    x += max(html.clientWidth, body.clientWidth) - width;\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    x,\r\n    y\r\n  };\r\n}\r\n\r\n// Safety check: ensure the scrollbar space is reasonable in case this\r\n// calculation is affected by unusual styles.\r\n// Most scrollbars leave 15-18px of space.\r\nconst SCROLLBAR_MAX = 25;\r\nfunction getViewportRect(element, strategy) {\r\n  const win = getWindow(element);\r\n  const html = getDocumentElement(element);\r\n  const visualViewport = win.visualViewport;\r\n  let width = html.clientWidth;\r\n  let height = html.clientHeight;\r\n  let x = 0;\r\n  let y = 0;\r\n  if (visualViewport) {\r\n    width = visualViewport.width;\r\n    height = visualViewport.height;\r\n    const visualViewportBased = isWebKit();\r\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\r\n      x = visualViewport.offsetLeft;\r\n      y = visualViewport.offsetTop;\r\n    }\r\n  }\r\n  const windowScrollbarX = getWindowScrollBarX(html);\r\n  // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the\r\n  // visual width of the <html> but this is not considered in the size\r\n  // of `html.clientWidth`.\r\n  if (windowScrollbarX <= 0) {\r\n    const doc = html.ownerDocument;\r\n    const body = doc.body;\r\n    const bodyStyles = getComputedStyle(body);\r\n    const bodyMarginInline = doc.compatMode === 'CSS1Compat' ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;\r\n    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);\r\n    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {\r\n      width -= clippingStableScrollbarWidth;\r\n    }\r\n  } else if (windowScrollbarX <= SCROLLBAR_MAX) {\r\n    // If the <body> scrollbar is on the left, the width needs to be extended\r\n    // by the scrollbar amount so there isn't extra space on the right.\r\n    width += windowScrollbarX;\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    x,\r\n    y\r\n  };\r\n}\r\n\r\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\r\n// Returns the inner client rect, subtracting scrollbars if present.\r\nfunction getInnerBoundingClientRect(element, strategy) {\r\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\r\n  const top = clientRect.top + element.clientTop;\r\n  const left = clientRect.left + element.clientLeft;\r\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\r\n  const width = element.clientWidth * scale.x;\r\n  const height = element.clientHeight * scale.y;\r\n  const x = left * scale.x;\r\n  const y = top * scale.y;\r\n  return {\r\n    width,\r\n    height,\r\n    x,\r\n    y\r\n  };\r\n}\r\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\r\n  let rect;\r\n  if (clippingAncestor === 'viewport') {\r\n    rect = getViewportRect(element, strategy);\r\n  } else if (clippingAncestor === 'document') {\r\n    rect = getDocumentRect(getDocumentElement(element));\r\n  } else if (isElement(clippingAncestor)) {\r\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\r\n  } else {\r\n    const visualOffsets = getVisualOffsets(element);\r\n    rect = {\r\n      x: clippingAncestor.x - visualOffsets.x,\r\n      y: clippingAncestor.y - visualOffsets.y,\r\n      width: clippingAncestor.width,\r\n      height: clippingAncestor.height\r\n    };\r\n  }\r\n  return rectToClientRect(rect);\r\n}\r\nfunction hasFixedPositionAncestor(element, stopNode) {\r\n  const parentNode = getParentNode(element);\r\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\r\n    return false;\r\n  }\r\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\r\n}\r\n\r\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\r\n// clipping (or hiding) child elements. This returns all clipping ancestors\r\n// of the given element up the tree.\r\nfunction getClippingElementAncestors(element, cache) {\r\n  const cachedResult = cache.get(element);\r\n  if (cachedResult) {\r\n    return cachedResult;\r\n  }\r\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\r\n  let currentContainingBlockComputedStyle = null;\r\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\r\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\r\n\r\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\r\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\r\n    const computedStyle = getComputedStyle$1(currentNode);\r\n    const currentNodeIsContaining = isContainingBlock(currentNode);\r\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\r\n      currentContainingBlockComputedStyle = null;\r\n    }\r\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\r\n    if (shouldDropCurrentNode) {\r\n      // Drop non-containing blocks.\r\n      result = result.filter(ancestor => ancestor !== currentNode);\r\n    } else {\r\n      // Record last containing block for next iteration.\r\n      currentContainingBlockComputedStyle = computedStyle;\r\n    }\r\n    currentNode = getParentNode(currentNode);\r\n  }\r\n  cache.set(element, result);\r\n  return result;\r\n}\r\n\r\n// Gets the maximum area that the element is visible in due to any number of\r\n// clipping ancestors.\r\nfunction getClippingRect(_ref) {\r\n  let {\r\n    element,\r\n    boundary,\r\n    rootBoundary,\r\n    strategy\r\n  } = _ref;\r\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\r\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\r\n  const firstClippingAncestor = clippingAncestors[0];\r\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\r\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\r\n    accRect.top = max(rect.top, accRect.top);\r\n    accRect.right = min(rect.right, accRect.right);\r\n    accRect.bottom = min(rect.bottom, accRect.bottom);\r\n    accRect.left = max(rect.left, accRect.left);\r\n    return accRect;\r\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\r\n  return {\r\n    width: clippingRect.right - clippingRect.left,\r\n    height: clippingRect.bottom - clippingRect.top,\r\n    x: clippingRect.left,\r\n    y: clippingRect.top\r\n  };\r\n}\r\n\r\nfunction getDimensions(element) {\r\n  const {\r\n    width,\r\n    height\r\n  } = getCssDimensions(element);\r\n  return {\r\n    width,\r\n    height\r\n  };\r\n}\r\n\r\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\r\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\r\n  const documentElement = getDocumentElement(offsetParent);\r\n  const isFixed = strategy === 'fixed';\r\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\r\n  let scroll = {\r\n    scrollLeft: 0,\r\n    scrollTop: 0\r\n  };\r\n  const offsets = createCoords(0);\r\n\r\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\r\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\r\n  function setLeftRTLScrollbarOffset() {\r\n    offsets.x = getWindowScrollBarX(documentElement);\r\n  }\r\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\r\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\r\n      scroll = getNodeScroll(offsetParent);\r\n    }\r\n    if (isOffsetParentAnElement) {\r\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\r\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\r\n      offsets.y = offsetRect.y + offsetParent.clientTop;\r\n    } else if (documentElement) {\r\n      setLeftRTLScrollbarOffset();\r\n    }\r\n  }\r\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\r\n    setLeftRTLScrollbarOffset();\r\n  }\r\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\r\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\r\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\r\n  return {\r\n    x,\r\n    y,\r\n    width: rect.width,\r\n    height: rect.height\r\n  };\r\n}\r\n\r\nfunction isStaticPositioned(element) {\r\n  return getComputedStyle$1(element).position === 'static';\r\n}\r\n\r\nfunction getTrueOffsetParent(element, polyfill) {\r\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\r\n    return null;\r\n  }\r\n  if (polyfill) {\r\n    return polyfill(element);\r\n  }\r\n  let rawOffsetParent = element.offsetParent;\r\n\r\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\r\n  // while Chrome and Safari return the <body> element. The <body> element must\r\n  // be used to perform the correct calculations even if the <html> element is\r\n  // non-static.\r\n  if (getDocumentElement(element) === rawOffsetParent) {\r\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\r\n  }\r\n  return rawOffsetParent;\r\n}\r\n\r\n// Gets the closest ancestor positioned element. Handles some edge cases,\r\n// such as table ancestors and cross browser bugs.\r\nfunction getOffsetParent(element, polyfill) {\r\n  const win = getWindow(element);\r\n  if (isTopLayer(element)) {\r\n    return win;\r\n  }\r\n  if (!isHTMLElement(element)) {\r\n    let svgOffsetParent = getParentNode(element);\r\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\r\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\r\n        return svgOffsetParent;\r\n      }\r\n      svgOffsetParent = getParentNode(svgOffsetParent);\r\n    }\r\n    return win;\r\n  }\r\n  let offsetParent = getTrueOffsetParent(element, polyfill);\r\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\r\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\r\n  }\r\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\r\n    return win;\r\n  }\r\n  return offsetParent || getContainingBlock(element) || win;\r\n}\r\n\r\nconst getElementRects = async function (data) {\r\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\r\n  const getDimensionsFn = this.getDimensions;\r\n  const floatingDimensions = await getDimensionsFn(data.floating);\r\n  return {\r\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\r\n    floating: {\r\n      x: 0,\r\n      y: 0,\r\n      width: floatingDimensions.width,\r\n      height: floatingDimensions.height\r\n    }\r\n  };\r\n};\r\n\r\nfunction isRTL(element) {\r\n  return getComputedStyle$1(element).direction === 'rtl';\r\n}\r\n\r\nconst platform = {\r\n  convertOffsetParentRelativeRectToViewportRelativeRect,\r\n  getDocumentElement,\r\n  getClippingRect,\r\n  getOffsetParent,\r\n  getElementRects,\r\n  getClientRects,\r\n  getDimensions,\r\n  getScale,\r\n  isElement,\r\n  isRTL\r\n};\r\n\r\nfunction rectsAreEqual(a, b) {\r\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\r\n}\r\n\r\n// https://samthor.au/2021/observing-dom/\r\nfunction observeMove(element, onMove) {\r\n  let io = null;\r\n  let timeoutId;\r\n  const root = getDocumentElement(element);\r\n  function cleanup() {\r\n    var _io;\r\n    clearTimeout(timeoutId);\r\n    (_io = io) == null || _io.disconnect();\r\n    io = null;\r\n  }\r\n  function refresh(skip, threshold) {\r\n    if (skip === void 0) {\r\n      skip = false;\r\n    }\r\n    if (threshold === void 0) {\r\n      threshold = 1;\r\n    }\r\n    cleanup();\r\n    const elementRectForRootMargin = element.getBoundingClientRect();\r\n    const {\r\n      left,\r\n      top,\r\n      width,\r\n      height\r\n    } = elementRectForRootMargin;\r\n    if (!skip) {\r\n      onMove();\r\n    }\r\n    if (!width || !height) {\r\n      return;\r\n    }\r\n    const insetTop = floor(top);\r\n    const insetRight = floor(root.clientWidth - (left + width));\r\n    const insetBottom = floor(root.clientHeight - (top + height));\r\n    const insetLeft = floor(left);\r\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\r\n    const options = {\r\n      rootMargin,\r\n      threshold: max(0, min(1, threshold)) || 1\r\n    };\r\n    let isFirstUpdate = true;\r\n    function handleObserve(entries) {\r\n      const ratio = entries[0].intersectionRatio;\r\n      if (ratio !== threshold) {\r\n        if (!isFirstUpdate) {\r\n          return refresh();\r\n        }\r\n        if (!ratio) {\r\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\r\n          // to prevent an infinite loop of updates.\r\n          timeoutId = setTimeout(() => {\r\n            refresh(false, 1e-7);\r\n          }, 1000);\r\n        } else {\r\n          refresh(false, ratio);\r\n        }\r\n      }\r\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\r\n        // It's possible that even though the ratio is reported as 1, the\r\n        // element is not actually fully within the IntersectionObserver's root\r\n        // area anymore. This can happen under performance constraints. This may\r\n        // be a bug in the browser's IntersectionObserver implementation. To\r\n        // work around this, we compare the element's bounding rect now with\r\n        // what it was at the time we created the IntersectionObserver. If they\r\n        // are not equal then the element moved, so we refresh.\r\n        refresh();\r\n      }\r\n      isFirstUpdate = false;\r\n    }\r\n\r\n    // Older browsers don't support a `document` as the root and will throw an\r\n    // error.\r\n    try {\r\n      io = new IntersectionObserver(handleObserve, {\r\n        ...options,\r\n        // Handle <iframe>s\r\n        root: root.ownerDocument\r\n      });\r\n    } catch (_e) {\r\n      io = new IntersectionObserver(handleObserve, options);\r\n    }\r\n    io.observe(element);\r\n  }\r\n  refresh(true);\r\n  return cleanup;\r\n}\r\n\r\n/**\r\n * Automatically updates the position of the floating element when necessary.\r\n * Should only be called when the floating element is mounted on the DOM or\r\n * visible on the screen.\r\n * @returns cleanup function that should be invoked when the floating element is\r\n * removed from the DOM or hidden from the screen.\r\n * @see https://floating-ui.com/docs/autoUpdate\r\n */\r\nfunction autoUpdate(reference, floating, update, options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  const {\r\n    ancestorScroll = true,\r\n    ancestorResize = true,\r\n    elementResize = typeof ResizeObserver === 'function',\r\n    layoutShift = typeof IntersectionObserver === 'function',\r\n    animationFrame = false\r\n  } = options;\r\n  const referenceEl = unwrapElement(reference);\r\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\r\n  ancestors.forEach(ancestor => {\r\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\r\n      passive: true\r\n    });\r\n    ancestorResize && ancestor.addEventListener('resize', update);\r\n  });\r\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\r\n  let reobserveFrame = -1;\r\n  let resizeObserver = null;\r\n  if (elementResize) {\r\n    resizeObserver = new ResizeObserver(_ref => {\r\n      let [firstEntry] = _ref;\r\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\r\n        // Prevent update loops when using the `size` middleware.\r\n        // https://github.com/floating-ui/floating-ui/issues/1740\r\n        resizeObserver.unobserve(floating);\r\n        cancelAnimationFrame(reobserveFrame);\r\n        reobserveFrame = requestAnimationFrame(() => {\r\n          var _resizeObserver;\r\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\r\n        });\r\n      }\r\n      update();\r\n    });\r\n    if (referenceEl && !animationFrame) {\r\n      resizeObserver.observe(referenceEl);\r\n    }\r\n    resizeObserver.observe(floating);\r\n  }\r\n  let frameId;\r\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\r\n  if (animationFrame) {\r\n    frameLoop();\r\n  }\r\n  function frameLoop() {\r\n    const nextRefRect = getBoundingClientRect(reference);\r\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\r\n      update();\r\n    }\r\n    prevRefRect = nextRefRect;\r\n    frameId = requestAnimationFrame(frameLoop);\r\n  }\r\n  update();\r\n  return () => {\r\n    var _resizeObserver2;\r\n    ancestors.forEach(ancestor => {\r\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\r\n      ancestorResize && ancestor.removeEventListener('resize', update);\r\n    });\r\n    cleanupIo == null || cleanupIo();\r\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\r\n    resizeObserver = null;\r\n    if (animationFrame) {\r\n      cancelAnimationFrame(frameId);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Resolves with an object of overflow side offsets that determine how much the\r\n * element is overflowing a given clipping boundary on each side.\r\n * - positive = overflowing the boundary by that number of pixels\r\n * - negative = how many pixels left before it will overflow\r\n * - 0 = lies flush with the boundary\r\n * @see https://floating-ui.com/docs/detectOverflow\r\n */\r\nconst detectOverflow = detectOverflow$1;\r\n\r\n/**\r\n * Modifies the placement by translating the floating element along the\r\n * specified axes.\r\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\r\n * object may be passed.\r\n * @see https://floating-ui.com/docs/offset\r\n */\r\nconst offset = offset$1;\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by choosing the placement\r\n * that has the most space available automatically, without needing to specify a\r\n * preferred placement. Alternative to `flip`.\r\n * @see https://floating-ui.com/docs/autoPlacement\r\n */\r\nconst autoPlacement = autoPlacement$1;\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by shifting it in order to\r\n * keep it in view when it will overflow the clipping boundary.\r\n * @see https://floating-ui.com/docs/shift\r\n */\r\nconst shift = shift$1;\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by flipping the `placement`\r\n * in order to keep it in view when the preferred placement(s) will overflow the\r\n * clipping boundary. Alternative to `autoPlacement`.\r\n * @see https://floating-ui.com/docs/flip\r\n */\r\nconst flip = flip$1;\r\n\r\n/**\r\n * Provides data that allows you to change the size of the floating element \r\n * for instance, prevent it from overflowing the clipping boundary or match the\r\n * width of the reference element.\r\n * @see https://floating-ui.com/docs/size\r\n */\r\nconst size = size$1;\r\n\r\n/**\r\n * Provides data to hide the floating element in applicable situations, such as\r\n * when it is not in the same clipping context as the reference element.\r\n * @see https://floating-ui.com/docs/hide\r\n */\r\nconst hide = hide$1;\r\n\r\n/**\r\n * Provides data to position an inner element of the floating element so that it\r\n * appears centered to the reference element.\r\n * @see https://floating-ui.com/docs/arrow\r\n */\r\nconst arrow = arrow$1;\r\n\r\n/**\r\n * Provides improved positioning for inline reference elements that can span\r\n * over multiple lines, such as hyperlinks or range selections.\r\n * @see https://floating-ui.com/docs/inline\r\n */\r\nconst inline = inline$1;\r\n\r\n/**\r\n * Built-in `limiter` that will stop `shift()` at a certain point.\r\n */\r\nconst limitShift = limitShift$1;\r\n\r\n/**\r\n * Computes the `x` and `y` coordinates that will place the floating element\r\n * next to a given reference element.\r\n */\r\nconst computePosition = (reference, floating, options) => {\r\n  // This caches the expensive `getClippingElementAncestors` function so that\r\n  // multiple lifecycle resets re-use the same result. It only lives for a\r\n  // single call. If other functions become expensive, we can add them as well.\r\n  const cache = new Map();\r\n  const mergedOptions = {\r\n    platform,\r\n    ...options\r\n  };\r\n  const platformWithCache = {\r\n    ...mergedOptions.platform,\r\n    _c: cache\r\n  };\r\n  return computePosition$1(reference, floating, {\r\n    ...mergedOptions,\r\n    platform: platformWithCache\r\n  });\r\n};\r\n\r\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\r\n", "// Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\nimport type { Attrs, Node } from 'prosemirror-model';\n\nimport type { CellAttrs } from './util';\n\n/**\n * @public\n */\nexport type ColWidths = number[];\n\n/**\n * @public\n */\nexport type Problem =\n  | {\n      type: 'colwidth mismatch';\n      pos: number;\n      colwidth: ColWidths;\n    }\n  | {\n      type: 'collision';\n      pos: number;\n      row: number;\n      n: number;\n    }\n  | {\n      type: 'missing';\n      row: number;\n      n: number;\n    }\n  | {\n      type: 'overlong_rowspan';\n      pos: number;\n      n: number;\n    }\n  | {\n      type: 'zero_sized';\n    };\n\nlet readFromCache: (key: Node) => TableMap | undefined;\nlet addToCache: (key: Node, value: TableMap) => TableMap;\n\n// Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\nif (typeof WeakMap != 'undefined') {\n  let cache = new WeakMap<Node, TableMap>();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache: (Node | TableMap)[] = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1] as TableMap;\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return (cache[cachePos++] = value);\n  };\n}\n\n/**\n * @public\n */\nexport interface Rect {\n  left: number;\n  top: number;\n  right: number;\n  bottom: number;\n}\n\n/**\n * A table map describes the structure of a given table. To avoid\n * recomputing them all the time, they are cached per table node. To\n * be able to do that, positions saved in the map are relative to the\n * start of the table, rather than the start of the document.\n *\n * @public\n */\nexport class TableMap {\n  constructor(\n    /**\n     * The number of columns\n     */\n    public width: number,\n    /**\n     * The number of rows\n     */\n    public height: number,\n    /**\n     * A width * height array with the start position of\n     * the cell covering that part of the table in each slot\n     */\n    public map: number[],\n    /**\n     * An optional array of problems (cell overlap or non-rectangular\n     * shape) for the table, used by the table normalizer.\n     */\n    public problems: Problem[] | null,\n  ) {}\n\n  // Find the dimensions of the cell at the given position.\n  findCell(pos: number): Rect {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos) continue;\n\n      const left = i % this.width;\n      const top = (i / this.width) | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (\n        let j = 1;\n        bottom < this.height && this.map[i + this.width * j] == curPos;\n        j++\n      ) {\n        bottom++;\n      }\n\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n\n  // Find the left side of the cell at the given position.\n  colCount(pos: number): number {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos: number, axis: 'horiz' | 'vert', dir: number): null | number {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == 'horiz') {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a: number, b: number): Rect {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA,\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB,\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB),\n    };\n  }\n\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect: Rect): number[] {\n    const result: number[] = [];\n    const seen: Record<number, boolean> = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n\n        if (seen[pos]) continue;\n        seen[pos] = true;\n\n        if (\n          (col == rect.left && col && this.map[index - 1] == pos) ||\n          (row == rect.top && row && this.map[index - this.width] == pos)\n        ) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row: number, col: number, table: Node): number {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        // Skip past cells from previous rows (via rowspan)\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n\n  // Find the table map for the given table node.\n  static get(table: Node): TableMap {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n}\n\n// Compute a table map.\nfunction computeMap(table: Node): TableMap {\n  if (table.type.spec.tableRole != 'table')\n    throw new RangeError('Not a table node: ' + table.type.name);\n  const width = findWidth(table),\n    height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems: Problem[] | null = null;\n  const colWidths: ColWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: 'overlong_rowspan',\n            pos,\n            n: rowspan - h,\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: 'collision',\n              row,\n              pos,\n              n: colspan - w,\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = ((start + w) % width) * 2,\n              prev = colWidths[widthIndex];\n            if (\n              prev == null ||\n              (prev != colW && colWidths[widthIndex + 1] == 1)\n            ) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: 'missing', row, n: missing });\n    pos++;\n  }\n\n  if (width === 0 || height === 0)\n    (problems || (problems = [])).push({ type: 'zero_sized' });\n\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n\n  // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n\n  return tableMap;\n}\n\nfunction findWidth(table: Node): number {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;\n    else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\n\nfunction findBadColWidths(\n  map: TableMap,\n  colWidths: ColWidths,\n  table: Node,\n): void {\n  if (!map.problems) map.problems = [];\n  const seen: Record<number, boolean> = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n\n    let updated = null;\n    const attrs = node.attrs as CellAttrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (\n        colWidth != null &&\n        (!attrs.colwidth || attrs.colwidth[j] != colWidth)\n      )\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: 'colwidth mismatch',\n        pos,\n        colwidth: updated,\n      });\n  }\n}\n\nfunction freshColWidth(attrs: Attrs): ColWidths {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  const result: ColWidths = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n", "// Helper for creating a schema that supports tables.\n\nimport type {\n  AttributeSpec,\n  Attrs,\n  Node,\n  NodeSpec,\n  NodeType,\n  Schema,\n} from 'prosemirror-model';\n\nimport type { CellAttrs, MutableAttrs } from './util';\n\nfunction getCellAttrs(dom: HTMLElement | string, extraAttrs: Attrs): Attrs {\n  if (typeof dom === 'string') {\n    return {};\n  }\n\n  const widthAttr = dom.getAttribute('data-colwidth');\n  const widths =\n    widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr)\n      ? widthAttr.split(',').map((s) => Number(s))\n      : null;\n  const colspan = Number(dom.getAttribute('colspan') || 1);\n  const result: MutableAttrs = {\n    colspan,\n    rowspan: Number(dom.getAttribute('rowspan') || 1),\n    colwidth: widths && widths.length == colspan ? widths : null,\n  } satisfies CellAttrs;\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\n\nfunction setCellAttrs(node: Node, extraAttrs: Attrs): Attrs {\n  const attrs: MutableAttrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs['data-colwidth'] = node.attrs.colwidth.join(',');\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\n\n/**\n * @public\n */\nexport type getFromDOM = (dom: HTMLElement) => unknown;\n\n/**\n * @public\n */\nexport type setDOMAttr = (value: unknown, attrs: MutableAttrs) => void;\n\n/**\n * @public\n */\nexport interface CellAttributes {\n  /**\n   * The attribute's default value.\n   */\n  default: unknown;\n\n  /**\n   * A function or type name used to validate values of this attribute.\n   *\n   * See [validate](https://prosemirror.net/docs/ref/#model.AttributeSpec.validate).\n   */\n  validate?: string | ((value: unknown) => void);\n\n  /**\n   * A function to read the attribute's value from a DOM node.\n   */\n  getFromDOM?: getFromDOM;\n\n  /**\n   * A function to add the attribute's value to an attribute\n   * object that's used to render the cell's DOM.\n   */\n  setDOMAttr?: setDOMAttr;\n}\n\n/**\n * @public\n */\nexport interface TableNodesOptions {\n  /**\n   * A group name (something like `\"block\"`) to add to the table\n   * node type.\n   */\n  tableGroup?: string;\n\n  /**\n   * The content expression for table cells.\n   */\n  cellContent: string;\n\n  /**\n   * Additional attributes to add to cells. Maps attribute names to\n   * objects with the following properties:\n   */\n  cellAttributes: { [key: string]: CellAttributes };\n}\n\n/**\n * @public\n */\nexport type TableNodes = Record<\n  'table' | 'table_row' | 'table_cell' | 'table_header',\n  NodeSpec\n>;\n\nfunction validateColwidth(value: unknown) {\n  if (value === null) {\n    return;\n  }\n  if (!Array.isArray(value)) {\n    throw new TypeError('colwidth must be null or an array');\n  }\n  for (const item of value) {\n    if (typeof item !== 'number') {\n      throw new TypeError('colwidth must be null or an array of numbers');\n    }\n  }\n}\n\n/**\n * This function creates a set of [node\n * specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n * `table`, `table_row`, and `table_cell` nodes types as used by this\n * module. The result can then be added to the set of nodes when\n * creating a schema.\n *\n * @public\n */\nexport function tableNodes(options: TableNodesOptions): TableNodes {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs: Record<string, AttributeSpec> = {\n    colspan: { default: 1, validate: 'number' },\n    rowspan: { default: 1, validate: 'number' },\n    colwidth: { default: null, validate: validateColwidth },\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = {\n      default: extraAttrs[prop].default,\n      validate: extraAttrs[prop].validate,\n    };\n\n  return {\n    table: {\n      content: 'table_row+',\n      tableRole: 'table',\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: 'table' }],\n      toDOM() {\n        return ['table', ['tbody', 0]];\n      },\n    },\n    table_row: {\n      content: '(table_cell | table_header)*',\n      tableRole: 'row',\n      parseDOM: [{ tag: 'tr' }],\n      toDOM() {\n        return ['tr', 0];\n      },\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: 'cell',\n      isolating: true,\n      parseDOM: [\n        { tag: 'td', getAttrs: (dom) => getCellAttrs(dom, extraAttrs) },\n      ],\n      toDOM(node) {\n        return ['td', setCellAttrs(node, extraAttrs), 0];\n      },\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: 'header_cell',\n      isolating: true,\n      parseDOM: [\n        { tag: 'th', getAttrs: (dom) => getCellAttrs(dom, extraAttrs) },\n      ],\n      toDOM(node) {\n        return ['th', setCellAttrs(node, extraAttrs), 0];\n      },\n    },\n  };\n}\n\n/**\n * @public\n */\nexport type TableRole = 'table' | 'row' | 'cell' | 'header_cell';\n\n/**\n * @public\n */\nexport function tableNodeTypes(schema: Schema): Record<TableRole, NodeType> {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name],\n        role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n", "// Various helper function for working with tables\n\nimport type { Attrs, Node, ResolvedPos } from 'prosemirror-model';\nimport type { EditorState, NodeSelection } from 'prosemirror-state';\nimport { PluginKey } from 'prosemirror-state';\n\nimport type { CellSelection } from './cellselection';\nimport { tableNodeTypes } from './schema';\nimport type { Rect } from './tablemap';\nimport { TableMap } from './tablemap';\n\n/**\n * @public\n */\nexport type MutableAttrs = Record<string, unknown>;\n\n/**\n * @public\n */\nexport interface CellAttrs {\n  colspan: number;\n  rowspan: number;\n  colwidth: number[] | null;\n}\n\n/**\n * @public\n */\nexport const tableEditingKey = new PluginKey<number>('selectingCells');\n\n/**\n * @public\n */\nexport function cellAround($pos: ResolvedPos): ResolvedPos | null {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == 'row')\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\n\nexport function cellWrapping($pos: ResolvedPos): null | Node {\n  for (let d = $pos.depth; d > 0; d--) {\n    // Sometimes the cell can be in the same depth.\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === 'cell' || role === 'header_cell') return $pos.node(d);\n  }\n  return null;\n}\n\n/**\n * @public\n */\nexport function isInTable(state: EditorState): boolean {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == 'row') return true;\n  return false;\n}\n\n/**\n * @internal\n */\nexport function selectionCell(state: EditorState): ResolvedPos {\n  const sel = state.selection as CellSelection | NodeSelection;\n  if ('$anchorCell' in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos\n      ? sel.$anchorCell\n      : sel.$headCell;\n  } else if (\n    'node' in sel &&\n    sel.node &&\n    sel.node.type.spec.tableRole == 'cell'\n  ) {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\n\n/**\n * @public\n */\nexport function cellNear($pos: ResolvedPos): ResolvedPos | undefined {\n  for (\n    let after = $pos.nodeAfter, pos = $pos.pos;\n    after;\n    after = after.firstChild, pos++\n  ) {\n    const role = after.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell') return $pos.doc.resolve(pos);\n  }\n  for (\n    let before = $pos.nodeBefore, pos = $pos.pos;\n    before;\n    before = before.lastChild, pos--\n  ) {\n    const role = before.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell')\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\n\n/**\n * @public\n */\nexport function pointsAtCell($pos: ResolvedPos): boolean {\n  return $pos.parent.type.spec.tableRole == 'row' && !!$pos.nodeAfter;\n}\n\n/**\n * @public\n */\nexport function moveCellForward($pos: ResolvedPos): ResolvedPos {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter!.nodeSize);\n}\n\n/**\n * @internal\n */\nexport function inSameTable($cellA: ResolvedPos, $cellB: ResolvedPos): boolean {\n  return (\n    $cellA.depth == $cellB.depth &&\n    $cellA.pos >= $cellB.start(-1) &&\n    $cellA.pos <= $cellB.end(-1)\n  );\n}\n\n/**\n * @public\n */\nexport function findCell($pos: ResolvedPos): Rect {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\n\n/**\n * @public\n */\nexport function colCount($pos: ResolvedPos): number {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\n\n/**\n * @public\n */\nexport function nextCell(\n  $pos: ResolvedPos,\n  axis: 'horiz' | 'vert',\n  dir: number,\n): ResolvedPos | null {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\n\n/**\n * @public\n */\nexport function removeColSpan(attrs: CellAttrs, pos: number, n = 1): CellAttrs {\n  const result: CellAttrs = { ...attrs, colspan: attrs.colspan - n };\n\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\n\n/**\n * @public\n */\nexport function addColSpan(attrs: CellAttrs, pos: number, n = 1): Attrs {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\n\n/**\n * @public\n */\nexport function columnIsHeader(\n  map: TableMap,\n  table: Node,\n  col: number,\n): boolean {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width])!.type != headerCell)\n      return false;\n  return true;\n}\n", "// This file defines a ProseMirror selection subclass that models\n// table cell selections. The table plugin needs to be active to wire\n// in the user interaction part of table selections (so that you\n// actually get such selections when you select across cells).\n\nimport type { Node, ResolvedPos } from 'prosemirror-model';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport type { EditorState, Transaction } from 'prosemirror-state';\nimport {\n  NodeSelection,\n  Selection,\n  SelectionRange,\n  TextSelection,\n} from 'prosemirror-state';\nimport type { Mappable } from 'prosemirror-transform';\nimport type { DecorationSource } from 'prosemirror-view';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\n\nimport { TableMap } from './tablemap';\nimport type { CellAttrs } from './util';\nimport { inSameTable, pointsAtCell, removeColSpan } from './util';\n\n/**\n * @public\n */\nexport interface CellSelectionJSON {\n  type: string;\n  anchor: number;\n  head: number;\n}\n\n/**\n * A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n * subclass that represents a cell selection spanning part of a table.\n * With the plugin enabled, these will be created when the user\n * selects across cells, and will be drawn by giving selected cells a\n * `selectedCell` CSS class.\n *\n * @public\n */\nexport class CellSelection extends Selection {\n  // A resolved position pointing _in front of_ the anchor cell (the one\n  // that doesn't move when extending the selection).\n  public $anchorCell: ResolvedPos;\n\n  // A resolved position pointing in front of the head cell (the one\n  // moves when extending the selection).\n  public $headCell: ResolvedPos;\n\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell: ResolvedPos, $headCell: ResolvedPos = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart,\n    );\n\n    const doc = $anchorCell.node(0);\n    const cells = map\n      .cellsInRect(rect)\n      .filter((p) => p != $headCell.pos - tableStart);\n    // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw new RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size),\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n\n  public map(doc: Node, mapping: Mappable): CellSelection | Selection {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (\n      pointsAtCell($anchorCell) &&\n      pointsAtCell($headCell) &&\n      inSameTable($anchorCell, $headCell)\n    ) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return CellSelection.colSelection($anchorCell, $headCell);\n      else return new CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  public override content(): Slice {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart,\n    );\n    const seen: Record<number, boolean> = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (\n        let index = row * map.width + rect.left, col = rect.left;\n        col < rect.right;\n        col++, index++\n      ) {\n        const pos = map.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw new RangeError(`No cell with offset ${pos} found`);\n        }\n\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs as CellAttrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight,\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw new RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`,\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan:\n              Math.min(cellRect.bottom, rect.bottom) -\n              Math.max(cellRect.top, rect.top),\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs)!;\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n\n    const fragment =\n      this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n\n  public override replace(tr: Transaction, content: Slice = Slice.empty): void {\n    const mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content,\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1,\n    );\n    if (sel) tr.setSelection(sel);\n  }\n\n  public override replaceWith(tr: Transaction, node: Node): void {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n\n  public forEachCell(f: (node: Node, pos: number) => void): void {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart,\n      ),\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i])!, tableStart + cells[i]);\n    }\n  }\n\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  public isColSelection(): boolean {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter!.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter!.attrs.rowspan;\n\n    return (\n      Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount\n    );\n  }\n\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  public static colSelection(\n    $anchorCell: ResolvedPos,\n    $headCell: ResolvedPos = $anchorCell,\n  ): CellSelection {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart +\n            map.map[map.width * (map.height - 1) + headRect.right - 1],\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart +\n            map.map[map.width * (map.height - 1) + anchorRect.right - 1],\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  public isRowSelection(): boolean {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter!.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter!.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n\n  public eq(other: unknown): boolean {\n    return (\n      other instanceof CellSelection &&\n      other.$anchorCell.pos == this.$anchorCell.pos &&\n      other.$headCell.pos == this.$headCell.pos\n    );\n  }\n\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  public static rowSelection(\n    $anchorCell: ResolvedPos,\n    $headCell: ResolvedPos = $anchorCell,\n  ): CellSelection {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width],\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1],\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1],\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n\n  public toJSON(): CellSelectionJSON {\n    return {\n      type: 'cell',\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos,\n    };\n  }\n\n  public static override fromJSON(\n    doc: Node,\n    json: CellSelectionJSON,\n  ): CellSelection {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n\n  static create(\n    doc: Node,\n    anchorCell: number,\n    headCell: number = anchorCell,\n  ): CellSelection {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n\n  public override getBookmark(): CellBookmark {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n}\n\nCellSelection.prototype.visible = false;\n\nSelection.jsonID('cell', CellSelection);\n\n/**\n * @public\n */\nexport class CellBookmark {\n  constructor(\n    public anchor: number,\n    public head: number,\n  ) {}\n\n  map(mapping: Mappable): CellBookmark {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n\n  resolve(doc: Node): CellSelection | Selection {\n    const $anchorCell = doc.resolve(this.anchor),\n      $headCell = doc.resolve(this.head);\n    if (\n      $anchorCell.parent.type.spec.tableRole == 'row' &&\n      $headCell.parent.type.spec.tableRole == 'row' &&\n      $anchorCell.index() < $anchorCell.parent.childCount &&\n      $headCell.index() < $headCell.parent.childCount &&\n      inSameTable($anchorCell, $headCell)\n    )\n      return new CellSelection($anchorCell, $headCell);\n    else return Selection.near($headCell, 1);\n  }\n}\n\nexport function drawCellSelection(state: EditorState): DecorationSource | null {\n  if (!(state.selection instanceof CellSelection)) return null;\n  const cells: Decoration[] = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: 'selectedCell' }),\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\n\nfunction isCellBoundarySelection({ $from, $to }: TextSelection) {\n  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false; // Cheap elimination\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break;\n  return (\n    afterFrom == beforeTo &&\n    /row|table/.test($from.node(depth).type.spec.tableRole)\n  );\n}\n\nfunction isTextSelectionAcrossCells({ $from, $to }: TextSelection) {\n  let fromCellBoundaryNode: Node | undefined;\n  let toCellBoundaryNode: Node | undefined;\n\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (\n      node.type.spec.tableRole === 'cell' ||\n      node.type.spec.tableRole === 'header_cell'\n    ) {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (\n      node.type.spec.tableRole === 'cell' ||\n      node.type.spec.tableRole === 'header_cell'\n    ) {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\n\nexport function normalizeSelection(\n  state: EditorState,\n  tr: Transaction | undefined,\n  allowTableNodeSelection: boolean,\n): Transaction | undefined {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize: Selection | undefined;\n  let role: string | undefined;\n  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == 'cell' || role == 'header_cell') {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == 'row') {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n", "// This file defines helpers for normalizing tables, making sure no\n// cells overlap (which can happen, if you have the wrong col- and\n// rowspans) and that each row has the same width. Uses the problems\n// reported by `TableMap`.\n\nimport type { Node } from 'prosemirror-model';\nimport type { EditorState, Transaction } from 'prosemirror-state';\nimport { PluginKey } from 'prosemirror-state';\n\nimport type { TableRole } from './schema';\nimport { tableNodeTypes } from './schema';\nimport { TableMap } from './tablemap';\nimport type { CellAttrs } from './util';\nimport { removeColSpan } from './util';\n\n/**\n * @public\n */\nexport const fixTablesKey = new PluginKey<{ fixTables: boolean }>('fix-tables');\n\n/**\n * Helper for iterating through the nodes in a document that changed\n * compared to the given previous document. Useful for avoiding\n * duplicate work on each transaction.\n *\n * @public\n */\nfunction changedDescendants(\n  old: Node,\n  cur: Node,\n  offset: number,\n  f: (node: Node, pos: number) => void,\n): void {\n  const oldSize = old.childCount,\n    curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    const child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f);\n    else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\n\n/**\n * Inspect all tables in the given state's document and return a\n * transaction that fixes them, if necessary. If `oldState` was\n * provided, that is assumed to hold a previous, known-good state,\n * which will be used to avoid re-scanning unchanged parts of the\n * document.\n *\n * @public\n */\nexport function fixTables(\n  state: EditorState,\n  oldState?: EditorState,\n): Transaction | undefined {\n  let tr: Transaction | undefined;\n  const check = (node: Node, pos: number) => {\n    if (node.type.spec.tableRole == 'table')\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState) state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\n\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\nexport function fixTable(\n  state: EditorState,\n  table: Node,\n  tablePos: number,\n  tr: Transaction | undefined,\n): Transaction | undefined {\n  const map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n\n  // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n  const mustAdd: number[] = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == 'collision') {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      const attrs = cell.attrs as CellAttrs;\n      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n),\n      );\n    } else if (prob.type == 'missing') {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == 'overlong_rowspan') {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n,\n      });\n    } else if (prob.type == 'colwidth mismatch') {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth,\n      });\n    } else if (prob.type == 'zero_sized') {\n      const pos = tr.mapping.map(tablePos);\n      tr.delete(pos, pos + table.nodeSize);\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null) first = i;\n      last = i;\n    }\n  // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role: TableRole = 'cell';\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes: Node[] = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n\n        if (node) nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n", "import type { Node } from 'prosemirror-model';\n\nimport { TableMap } from '../tablemap';\n\n/**\n * This function will transform the table node into a matrix of rows and columns\n * respecting merged cells, for example this table:\n *\n * ```\n * \n *   A1    B1       C1      \n * \n *   A2       B2            \n *   D1  \n *   A3    B3    C3        \n * \n * ```\n *\n * will be converted to the below:\n *\n * ```javascript\n * [\n *   [A1, B1, C1, null],\n *   [A2, B2, null, D1],\n *   [A3, B3, C3, null],\n * ]\n * ```\n * @internal\n */\nexport function convertTableNodeToArrayOfRows(\n  tableNode: Node,\n): (Node | null)[][] {\n  const map = TableMap.get(tableNode);\n  const rows: (Node | null)[][] = [];\n  const rowCount = map.height;\n  const colCount = map.width;\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row: (Node | null)[] = [];\n    for (let colIndex = 0; colIndex < colCount; colIndex++) {\n      const cellIndex = rowIndex * colCount + colIndex;\n      const cellPos = map.map[cellIndex];\n      if (rowIndex > 0) {\n        const topCellIndex = cellIndex - colCount;\n        const topCellPos = map.map[topCellIndex];\n        if (cellPos === topCellPos) {\n          row.push(null);\n          continue;\n        }\n      }\n      if (colIndex > 0) {\n        const leftCellIndex = cellIndex - 1;\n        const leftCellPos = map.map[leftCellIndex];\n        if (cellPos === leftCellPos) {\n          row.push(null);\n          continue;\n        }\n      }\n      row.push(tableNode.nodeAt(cellPos));\n    }\n    rows.push(row);\n  }\n\n  return rows;\n}\n\n/**\n * Convert an array of rows to a table node.\n *\n * @internal\n */\nexport function convertArrayOfRowsToTableNode(\n  tableNode: Node,\n  arrayOfNodes: (Node | null)[][],\n): Node {\n  const newRows: Node[] = [];\n  const map = TableMap.get(tableNode);\n  const rowCount = map.height;\n  const colCount = map.width;\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const oldRow: Node = tableNode.child(rowIndex);\n    const newCells: Node[] = [];\n\n    for (let colIndex = 0; colIndex < colCount; colIndex++) {\n      const cell = arrayOfNodes[rowIndex][colIndex];\n      if (!cell) {\n        continue;\n      }\n\n      const cellPos = map.map[rowIndex * map.width + colIndex];\n      const oldCell = tableNode.nodeAt(cellPos);\n      if (!oldCell) {\n        continue;\n      }\n\n      const newCell = oldCell.type.createChecked(\n        cell.attrs,\n        cell.content,\n        cell.marks,\n      );\n      newCells.push(newCell);\n    }\n\n    const newRow = oldRow.type.createChecked(\n      oldRow.attrs,\n      newCells,\n      oldRow.marks,\n    );\n    newRows.push(newRow);\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    newRows,\n    tableNode.marks,\n  );\n  return newTable;\n}\n", "/**\n * Move a row in an array of rows.\n *\n * @internal\n */\nexport function moveRowInArrayOfRows<T>(\n  rows: T[],\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  directionOverride: -1 | 1 | 0,\n): T[] {\n  const direction = indexesOrigin[0] > indexesTarget[0] ? -1 : 1;\n\n  const rowsExtracted = rows.splice(indexesOrigin[0], indexesOrigin.length);\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0;\n  let target: number;\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0] - 1;\n  } else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1] - positionOffset + 1;\n  } else {\n    target =\n      direction === -1\n        ? indexesTarget[0]\n        : indexesTarget[indexesTarget.length - 1] - positionOffset;\n  }\n\n  rows.splice(target, 0, ...rowsExtracted);\n  return rows;\n}\n", "import type { Node, ResolvedPos } from 'prosemirror-model';\nimport type { Selection } from 'prosemirror-state';\n\nimport { CellSelection } from '../cellselection';\nimport { cellAround, cellNear, inSameTable } from '../util';\n\n/**\n * Checks if the given object is a `CellSelection` instance.\n *\n * @internal\n */\nfunction isCellSelection(value: unknown): value is CellSelection {\n  return value instanceof CellSelection;\n}\n\n/**\n * Find the closest table node for a given position.\n *\n * @public\n */\nexport function findTable($pos: ResolvedPos): FindNodeResult | null {\n  return findParentNode((node) => node.type.spec.tableRole === 'table', $pos);\n}\n\n/**\n * Try to find the anchor and head cell in the same table by using the given\n * anchor and head as hit points, or fallback to the selection's anchor and\n * head.\n *\n * @public\n */\nexport function findCellRange(\n  selection: Selection,\n  anchorHit?: number,\n  headHit?: number,\n): [ResolvedPos, ResolvedPos] | null {\n  if (anchorHit == null && headHit == null && isCellSelection(selection)) {\n    return [selection.$anchorCell, selection.$headCell];\n  }\n\n  const anchor: number = anchorHit ?? headHit ?? selection.anchor;\n  const head: number = headHit ?? anchorHit ?? selection.head;\n\n  const doc = selection.$head.doc;\n\n  const $anchorCell = findCellPos(doc, anchor);\n  const $headCell = findCellPos(doc, head);\n\n  if ($anchorCell && $headCell && inSameTable($anchorCell, $headCell)) {\n    return [$anchorCell, $headCell];\n  }\n  return null;\n}\n\n/**\n * Try to find a resolved pos of a cell by using the given pos as a hit point.\n *\n * @public\n */\nexport function findCellPos(doc: Node, pos: number): ResolvedPos | undefined {\n  const $pos = doc.resolve(pos);\n  return cellAround($pos) || cellNear($pos);\n}\n\n/**\n * Result of finding a parent node.\n *\n * @public\n */\nexport interface FindNodeResult {\n  /**\n   * The closest parent node that satisfies the predicate.\n   */\n  node: Node;\n\n  /**\n   * The position directly before the node.\n   */\n  pos: number;\n\n  /**\n   * The position at the start of the node.\n   */\n  start: number;\n\n  /**\n   * The depth of the node.\n   */\n  depth: number;\n}\n\n/**\n * Find the closest parent node that satisfies the predicate.\n *\n * @internal\n */\nfunction findParentNode(\n  /**\n   * The predicate to test the parent node.\n   */\n  predicate: (node: Node) => boolean,\n  /**\n   * The position to start searching from.\n   */\n  $pos: ResolvedPos,\n): FindNodeResult | null {\n  for (let depth = $pos.depth; depth >= 0; depth -= 1) {\n    const node = $pos.node(depth);\n\n    if (predicate(node)) {\n      const pos = depth === 0 ? 0 : $pos.before(depth);\n      const start = $pos.start(depth);\n      return { node, pos, start, depth };\n    }\n  }\n\n  return null;\n}\n", "import type { Selection } from 'prosemirror-state';\n\nimport { TableMap } from '../tablemap';\n\nimport type { FindNodeResult } from './query';\nimport { findTable } from './query';\n\n/**\n * Returns an array of cells in a column at the specified column index.\n *\n * @internal\n */\nexport function getCellsInColumn(\n  columnIndex: number,\n  selection: Selection,\n): FindNodeResult[] | undefined {\n  const table = findTable(selection.$from);\n  if (!table) {\n    return;\n  }\n\n  const map = TableMap.get(table.node);\n\n  if (columnIndex < 0 || columnIndex > map.width - 1) {\n    return;\n  }\n\n  const cells = map.cellsInRect({\n    left: columnIndex,\n    right: columnIndex + 1,\n    top: 0,\n    bottom: map.height,\n  });\n\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)!;\n    const pos = nodePos + table.start;\n    return { pos, start: pos + 1, node, depth: table.depth + 2 };\n  });\n}\n\n/**\n * Returns an array of cells in a row at the specified row index.\n *\n * @internal\n */\nexport function getCellsInRow(\n  rowIndex: number,\n  selection: Selection,\n): FindNodeResult[] | undefined {\n  const table = findTable(selection.$from);\n  if (!table) {\n    return;\n  }\n\n  const map = TableMap.get(table.node);\n\n  if (rowIndex < 0 || rowIndex > map.height - 1) {\n    return;\n  }\n\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: rowIndex,\n    bottom: rowIndex + 1,\n  });\n\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)!;\n    const pos = nodePos + table.start;\n    return { pos, start: pos + 1, node, depth: table.depth + 2 };\n  });\n}\n", "import type { ResolvedPos } from 'prosemirror-model';\nimport type { Transaction } from 'prosemirror-state';\n\nimport { getCellsInColumn, getCellsInRow } from './get-cells';\n\nexport type CellSelectionRange = {\n  $anchor: ResolvedPos;\n  $head: ResolvedPos;\n  // an array of column/row indexes\n  indexes: number[];\n};\n\n/**\n * Returns a range of rectangular selection spanning all merged cells around a\n * column at index `columnIndex`.\n *\n * Original implementation from Atlassian (Apache License 2.0)\n *\n * https://bitbucket.org/atlassian/atlassian-frontend-mirror/src/5f91cb871e8248bc3bae5ddc30bb9fd9200fadbb/editor/editor-tables/src/utils/get-selection-range-in-column.ts#editor/editor-tables/src/utils/get-selection-range-in-column.ts\n *\n * @internal\n */\nexport function getSelectionRangeInColumn(\n  tr: Transaction,\n  startColIndex: number,\n  endColIndex: number = startColIndex,\n): CellSelectionRange | undefined {\n  let startIndex = startColIndex;\n  let endIndex = endColIndex;\n\n  // looking for selection start column (startIndex)\n  for (let i = startColIndex; i >= 0; i--) {\n    const cells = getCellsInColumn(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1;\n        if (maybeEndIndex >= startIndex) {\n          startIndex = i;\n        }\n        if (maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = startColIndex; i <= endIndex; i++) {\n    const cells = getCellsInColumn(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1;\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInColumn(i, tr.selection);\n    if (maybeCells && maybeCells.length > 0) {\n      indexes.push(i);\n    }\n  }\n  startIndex = indexes[0];\n  endIndex = indexes[indexes.length - 1];\n\n  const firstSelectedColumnCells = getCellsInColumn(startIndex, tr.selection);\n  const firstRowCells = getCellsInRow(0, tr.selection);\n  if (!firstSelectedColumnCells || !firstRowCells) {\n    return;\n  }\n\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1].pos,\n  );\n\n  let headCell;\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInColumn(i, tr.selection);\n    if (columnCells && columnCells.length > 0) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j].pos === columnCells[0].pos) {\n          headCell = columnCells[0];\n          break;\n        }\n      }\n      if (headCell) {\n        break;\n      }\n    }\n  }\n  if (!headCell) {\n    return;\n  }\n\n  const $head = tr.doc.resolve(headCell.pos);\n  return { $anchor, $head, indexes };\n}\n\n/**\n * Returns a range of rectangular selection spanning all merged cells around a\n * row at index `rowIndex`.\n *\n * Original implementation from Atlassian (Apache License 2.0)\n *\n * https://bitbucket.org/atlassian/atlassian-frontend-mirror/src/5f91cb871e8248bc3bae5ddc30bb9fd9200fadbb/editor/editor-tables/src/utils/get-selection-range-in-row.ts#editor/editor-tables/src/utils/get-selection-range-in-row.ts\n *\n * @internal\n */\nexport function getSelectionRangeInRow(\n  tr: Transaction,\n  startRowIndex: number,\n  endRowIndex: number = startRowIndex,\n): CellSelectionRange | undefined {\n  let startIndex = startRowIndex;\n  let endIndex = endRowIndex;\n\n  // looking for selection start row (startIndex)\n  for (let i = startRowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n        if (maybeEndIndex >= startIndex) {\n          startIndex = i;\n        }\n        if (maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n  // looking for selection end row (endIndex)\n  for (let i = startRowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n        if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i, tr.selection);\n    if (maybeCells && maybeCells.length > 0) {\n      indexes.push(i);\n    }\n  }\n  startIndex = indexes[0];\n  endIndex = indexes[indexes.length - 1];\n\n  const firstSelectedRowCells = getCellsInRow(startIndex, tr.selection);\n  const firstColumnCells = getCellsInColumn(0, tr.selection);\n  if (!firstSelectedRowCells || !firstColumnCells) {\n    return;\n  }\n\n  const $anchor = tr.doc.resolve(\n    firstSelectedRowCells[firstSelectedRowCells.length - 1].pos,\n  );\n\n  let headCell;\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i, tr.selection);\n    if (rowCells && rowCells.length > 0) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j].pos === rowCells[0].pos) {\n          headCell = rowCells[0];\n          break;\n        }\n      }\n      if (headCell) {\n        break;\n      }\n    }\n  }\n  if (!headCell) {\n    return;\n  }\n\n  const $head = tr.doc.resolve(headCell.pos);\n  return { $anchor, $head, indexes };\n}\n", "/**\n * Transposes a 2D array by flipping columns to rows.\n *\n * Transposition is a familiar algebra concept where the matrix is flipped\n * along its diagonal. For more details, see:\n * https://en.wikipedia.org/wiki/Transpose\n *\n * @example\n * ```javascript\n * const arr = [\n *   ['a1', 'a2', 'a3'],\n *   ['b1', 'b2', 'b3'],\n *   ['c1', 'c2', 'c3'],\n *   ['d1', 'd2', 'd3'],\n * ];\n *\n * const result = transpose(arr);\n * result === [\n *   ['a1', 'b1', 'c1', 'd1'],\n *   ['a2', 'b2', 'c2', 'd2'],\n *   ['a3', 'b3', 'c3', 'd3'],\n * ]\n * ```\n */\nexport function transpose<T>(array: T[][]): T[][] {\n  return array[0].map((_, i) => {\n    return array.map((column) => column[i]);\n  });\n}\n", "import type { Node } from 'prosemirror-model';\nimport type { Transaction } from 'prosemirror-state';\n\nimport { CellSelection } from '../cellselection';\nimport { TableMap } from '../tablemap';\n\nimport {\n  convertArrayOfRowsToTableNode,\n  convertTableNodeToArrayOfRows,\n} from './convert';\nimport { moveRowInArrayOfRows } from './move-row-in-array-of-rows';\nimport { findTable } from './query';\nimport { getSelectionRangeInColumn } from './selection-range';\nimport { transpose } from './transpose';\n\n/**\n * Parameters for moving a column in a table.\n *\n * @internal\n */\nexport interface MoveColumnParams {\n  tr: Transaction;\n  originIndex: number;\n  targetIndex: number;\n  select: boolean;\n  pos: number;\n}\n\n/**\n * Move a column from index `origin` to index `target`.\n *\n * @internal\n */\nexport function moveColumn(moveColParams: MoveColumnParams): boolean {\n  const { tr, originIndex, targetIndex, select, pos } = moveColParams;\n  const $pos = tr.doc.resolve(pos);\n  const table = findTable($pos);\n  if (!table) return false;\n\n  const indexesOriginColumn = getSelectionRangeInColumn(\n    tr,\n    originIndex,\n  )?.indexes;\n  const indexesTargetColumn = getSelectionRangeInColumn(\n    tr,\n    targetIndex,\n  )?.indexes;\n\n  if (!indexesOriginColumn || !indexesTargetColumn) return false;\n\n  if (indexesOriginColumn.includes(targetIndex)) return false;\n\n  const newTable = moveTableColumn(\n    table.node,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    0,\n  );\n\n  tr.replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);\n\n  if (!select) return true;\n\n  const map = TableMap.get(newTable);\n  const start = table.start;\n  const index = targetIndex;\n  const lastCell = map.positionAt(map.height - 1, index, newTable);\n  const $lastCell = tr.doc.resolve(start + lastCell);\n\n  const firstCell = map.positionAt(0, index, newTable);\n  const $firstCell = tr.doc.resolve(start + firstCell);\n\n  tr.setSelection(CellSelection.colSelection($lastCell, $firstCell));\n  return true;\n}\n\nfunction moveTableColumn(\n  table: Node,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0,\n) {\n  let rows = transpose(convertTableNodeToArrayOfRows(table));\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n  rows = transpose(rows);\n\n  return convertArrayOfRowsToTableNode(table, rows);\n}\n", "import type { Node } from 'prosemirror-model';\nimport type { Transaction } from 'prosemirror-state';\n\nimport { CellSelection } from '../cellselection';\nimport { TableMap } from '../tablemap';\n\nimport {\n  convertArrayOfRowsToTableNode,\n  convertTableNodeToArrayOfRows,\n} from './convert';\nimport { moveRowInArrayOfRows } from './move-row-in-array-of-rows';\nimport { findTable } from './query';\nimport { getSelectionRangeInRow } from './selection-range';\n\n/**\n * Parameters for moving a row in a table.\n *\n * @internal\n */\nexport interface MoveRowParams {\n  tr: Transaction;\n  originIndex: number;\n  targetIndex: number;\n  select: boolean;\n  pos: number;\n}\n\n/**\n * Move a row from index `origin` to index `target`.\n *\n * @internal\n */\nexport function moveRow(moveRowParams: MoveRowParams): boolean {\n  const { tr, originIndex, targetIndex, select, pos } = moveRowParams;\n  const $pos = tr.doc.resolve(pos);\n  const table = findTable($pos);\n  if (!table) return false;\n\n  const indexesOriginRow = getSelectionRangeInRow(tr, originIndex)?.indexes;\n  const indexesTargetRow = getSelectionRangeInRow(tr, targetIndex)?.indexes;\n\n  if (!indexesOriginRow || !indexesTargetRow) return false;\n\n  if (indexesOriginRow.includes(targetIndex)) return false;\n\n  const newTable = moveTableRow(\n    table.node,\n    indexesOriginRow,\n    indexesTargetRow,\n    0,\n  );\n\n  tr.replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);\n\n  if (!select) return true;\n\n  const map = TableMap.get(newTable);\n  const start = table.start;\n  const index = targetIndex;\n  const lastCell = map.positionAt(index, map.width - 1, newTable);\n  const $lastCell = tr.doc.resolve(start + lastCell);\n\n  const firstCell = map.positionAt(index, 0, newTable);\n  const $firstCell = tr.doc.resolve(start + firstCell);\n\n  tr.setSelection(CellSelection.rowSelection($lastCell, $firstCell));\n  return true;\n}\n\nfunction moveTableRow(\n  table: Node,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0,\n) {\n  let rows = convertTableNodeToArrayOfRows(table);\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n\n  return convertArrayOfRowsToTableNode(table, rows);\n}\n", "// This file defines a number of table-related commands.\n\nimport type { Node, NodeType, ResolvedPos } from 'prosemirror-model';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport type { Command, EditorState, Transaction } from 'prosemirror-state';\nimport { TextSelection } from 'prosemirror-state';\n\nimport { CellSelection } from './cellselection';\nimport type { Direction } from './input';\nimport type { TableRole } from './schema';\nimport { tableNodeTypes } from './schema';\nimport type { Rect } from './tablemap';\nimport { TableMap } from './tablemap';\nimport type { CellAttrs } from './util';\nimport {\n  addColSpan,\n  cellAround,\n  cellWrapping,\n  columnIsHeader,\n  isInTable,\n  moveCellForward,\n  removeColSpan,\n  selectionCell,\n} from './util';\nimport { moveColumn } from './utils/move-column';\nimport { moveRow } from './utils/move-row';\n\n/**\n * @public\n */\nexport type TableRect = Rect & {\n  tableStart: number;\n  map: TableMap;\n  table: Node;\n};\n\n/**\n * Helper to get the selected rectangle in a table, if any. Adds table\n * map, table node, and table start offset to the object for\n * convenience.\n *\n * @public\n */\nexport function selectedRect(state: EditorState): TableRect {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect =\n    sel instanceof CellSelection\n      ? map.rectBetween(\n          sel.$anchorCell.pos - tableStart,\n          sel.$headCell.pos - tableStart,\n        )\n      : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\n\n/**\n * Add a column at the given position in a table.\n *\n * @public\n */\nexport function addColumn(\n  tr: Transaction,\n  { map, tableStart, table }: TableRect,\n  col: number,\n): Transaction {\n  let refColumn: number | null = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    // If this position falls inside a col-spanning cell\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos)!;\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs as CellAttrs, col - map.colCount(pos)),\n      );\n      // Skip ahead if rowspan > 1\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type =\n        refColumn == null\n          ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refColumn])!.type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill()!);\n    }\n  }\n  return tr;\n}\n\n/**\n * Command to add a column before the column with the selection.\n *\n * @public\n */\nexport function addColumnBefore(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\n\n/**\n * Command to add a column after the column with the selection.\n *\n * @public\n */\nexport function addColumnAfter(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\n\n/**\n * @public\n */\nexport function removeColumn(\n  tr: Transaction,\n  { map, table, tableStart }: TableRect,\n  col: number,\n) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos)!;\n    const attrs = cell.attrs as CellAttrs;\n    // If this is part of a col-spanning cell\n    if (\n      (col > 0 && map.map[index - 1] == pos) ||\n      (col < map.width - 1 && map.map[index + 1] == pos)\n    ) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos)),\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\n\n/**\n * Command function that removes the selected columns from a table.\n *\n * @public\n */\nexport function deleteColumn(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      const table = rect.tableStart\n        ? tr.doc.nodeAt(rect.tableStart - 1)\n        : tr.doc;\n      if (!table) {\n        throw new RangeError('No table found');\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\n\n/**\n * @public\n */\nexport function rowIsHeader(map: TableMap, table: Node, row: number): boolean {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (table.nodeAt(map.map[col + row * map.width])?.type != headerCell)\n      return false;\n  return true;\n}\n\n/**\n * @public\n */\nexport function addRow(\n  tr: Transaction,\n  { map, tableStart, table }: TableRect,\n  row: number,\n): Transaction {\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow: number | null = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (\n      row > 0 &&\n      row < map.height &&\n      map.map[index] == map.map[index - map.width]\n    ) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos)!.attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1,\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type =\n        refRow == null\n          ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refRow * map.width])?.type;\n      const node = type?.createAndFill();\n      if (node) cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\n\n/**\n * Add a table row before the selection.\n *\n * @public\n */\nexport function addRowBefore(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\n\n/**\n * Add a table row after the selection.\n *\n * @public\n */\nexport function addRowAfter(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\n\n/**\n * @public\n */\nexport function removeRow(\n  tr: Transaction,\n  { map, table, tableStart }: TableRect,\n  row: number,\n): void {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n\n  const seen = new Set<number>();\n\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n\n    // Skip cells that are checked already\n    if (seen.has(pos)) continue;\n    seen.add(pos);\n\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      const attrs = table.nodeAt(pos)!.attrs as CellAttrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1,\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      const cell = table.nodeAt(pos)!;\n      const attrs = cell.attrs as CellAttrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content,\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\n\n/**\n * Remove the selected rows from a table.\n *\n * @public\n */\nexport function deleteRow(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state),\n      tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      const table = rect.tableStart\n        ? tr.doc.nodeAt(rect.tableStart - 1)\n        : tr.doc;\n      if (!table) {\n        throw new RangeError('No table found');\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\n\nfunction isEmpty(cell: Node): boolean {\n  const c = cell.content;\n\n  return (\n    c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0\n  );\n}\n\nfunction cellsOverlapRectangle({ width, height, map }: TableMap, rect: Rect) {\n  let indexTop = rect.top * width + rect.left,\n    indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left,\n    indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (\n      (rect.left > 0 && map[indexLeft] == map[indexLeft - 1]) ||\n      (rect.right < width && map[indexRight] == map[indexRight + 1])\n    )\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (\n      (rect.top > 0 && map[indexTop] == map[indexTop - width]) ||\n      (rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n    )\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\n\n/**\n * Merge the selected cells into a single cell. Only available when\n * the selected cells' outline forms a rectangle.\n *\n * @public\n */\nexport function mergeCells(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  const sel = state.selection;\n  if (\n    !(sel instanceof CellSelection) ||\n    sel.$anchorCell.pos == sel.$headCell.pos\n  )\n    return false;\n  const rect = selectedRect(state),\n    { map } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen: Record<number, boolean> = {};\n    let content = Fragment.empty;\n    let mergedPos: number | undefined;\n    let mergedCell: Node | undefined;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs as CellAttrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan,\n      ),\n      rowspan: rect.bottom - rect.top,\n    });\n    if (content.size > 0) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)),\n    );\n    dispatch(tr);\n  }\n  return true;\n}\n\n/**\n * Split a selected cell, whose rowpan or colspan is greater than one,\n * into smaller cells. Use the first cell type for the new cells.\n *\n * @public\n */\nexport function splitCell(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole as TableRole];\n  })(state, dispatch);\n}\n\n/**\n * @public\n */\nexport interface GetCellTypeOptions {\n  node: Node;\n  row: number;\n  col: number;\n}\n\n/**\n * Split a selected cell, whose rowpan or colspan is greater than one,\n * into smaller cells with the cell type (th, td) returned by getType function.\n *\n * @public\n */\nexport function splitCellWithType(\n  getCellType: (options: GetCellTypeOptions) => NodeType,\n): Command {\n  return (state, dispatch) => {\n    const sel = state.selection;\n    let cellNode: Node | null | undefined;\n    let cellPos: number | undefined;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = cellAround(sel.$from)?.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state),\n        tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth\n            ? {\n                ...baseAttrs,\n                colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null,\n              }\n            : baseAttrs,\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(\n            (lastCell = tr.mapping.map(pos + rect.tableStart, 1)),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])!,\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0],\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : undefined,\n          ),\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Returns a command that sets the given attribute to the given value,\n * and is only available when the currently selected cell doesn't\n * already have that attribute set to that value.\n *\n * @public\n */\nexport function setCellAttr(name: string, value: unknown): Command {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter!.attrs[name] === value) return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value,\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter!.attrs,\n          [name]: value,\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\nfunction deprecated_toggleHeader(type: ToggleHeaderType): Command {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state),\n        tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == 'column'\n          ? {\n              left: rect.left,\n              top: 0,\n              right: rect.right,\n              bottom: rect.map.height,\n            }\n          : type == 'row'\n            ? {\n                left: 0,\n                top: rect.top,\n                right: rect.map.width,\n                bottom: rect.bottom,\n              }\n            : rect,\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos)!);\n      for (\n        let i = 0;\n        i < cells.length;\n        i++ // Remove headers, if any\n      )\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs,\n          );\n      if (tr.steps.length === 0)\n        for (\n          let i = 0;\n          i < cells.length;\n          i++ // No headers removed, add instead\n        )\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs,\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\nfunction isHeaderEnabledByType(\n  type: 'row' | 'column',\n  rect: TableRect,\n  types: Record<string, NodeType>,\n): boolean {\n  // Get cell positions for first row or first column\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == 'row' ? rect.map.width : 1,\n    bottom: type == 'column' ? rect.map.height : 1,\n  });\n\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @public\n */\nexport type ToggleHeaderType = 'column' | 'row' | 'cell';\n\n/**\n * Toggles between row/column header and normal cells (Only applies to first row/column).\n * For deprecated behavior pass `useDeprecatedLogic` in options with true.\n *\n * @public\n */\nexport function toggleHeader(\n  type: ToggleHeaderType,\n  options?: { useDeprecatedLogic: boolean },\n): Command {\n  options = options || { useDeprecatedLogic: false };\n\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state),\n        tr = state.tr;\n\n      const isHeaderRowEnabled = isHeaderEnabledByType('row', rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        'column',\n        rect,\n        types,\n      );\n\n      const isHeaderEnabled =\n        type === 'column'\n          ? isHeaderRowEnabled\n          : type === 'row'\n            ? isHeaderColumnEnabled\n            : false;\n\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n\n      const cellsRect =\n        type == 'column'\n          ? {\n              left: 0,\n              top: selectionStartsAt,\n              right: 1,\n              bottom: rect.map.height,\n            }\n          : type == 'row'\n            ? {\n                left: selectionStartsAt,\n                top: 0,\n                right: rect.map.width,\n                bottom: 1,\n              }\n            : rect;\n\n      const newType =\n        type == 'column'\n          ? isHeaderColumnEnabled\n            ? types.cell\n            : types.header_cell\n          : type == 'row'\n            ? isHeaderRowEnabled\n              ? types.cell\n              : types.header_cell\n            : types.cell;\n\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Toggles whether the selected row contains header cells.\n *\n * @public\n */\nexport const toggleHeaderRow: Command = toggleHeader('row', {\n  useDeprecatedLogic: true,\n});\n\n/**\n * Toggles whether the selected column contains header cells.\n *\n * @public\n */\nexport const toggleHeaderColumn: Command = toggleHeader('column', {\n  useDeprecatedLogic: true,\n});\n\n/**\n * Toggles whether the selected cells are header cells.\n *\n * @public\n */\nexport const toggleHeaderCell: Command = toggleHeader('cell', {\n  useDeprecatedLogic: true,\n});\n\nfunction findNextCell($cell: ResolvedPos, dir: Direction): number | null {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (\n      let row = $cell.index(-1) - 1, rowEnd = $cell.before();\n      row >= 0;\n      row--\n    ) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter!.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (\n      let row = $cell.indexAfter(-1), rowStart = $cell.after();\n      row < table.childCount;\n      row++\n    ) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\n\n/**\n * Returns a command for selecting the next (direction=1) or previous\n * (direction=-1) cell in a table.\n *\n * @public\n */\nexport function goToNextCell(direction: Direction): Command {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr\n          .setSelection(TextSelection.between($cell, moveCellForward($cell)))\n          .scrollIntoView(),\n      );\n    }\n    return true;\n  };\n}\n\n/**\n * Deletes the table around the selection, if any.\n *\n * @public\n */\nexport function deleteTable(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == 'table') {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView(),\n        );\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Deletes the content of the selected cells, if they are not empty.\n *\n * @public\n */\nexport function deleteCellSelection(\n  state: EditorState,\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill()!\n      .content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice(baseContent, 0, 0),\n        );\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\n\n/**\n * Options for moveTableRow\n *\n * @public\n */\nexport interface MoveTableRowOptions {\n  /**\n   * The source row index to move from.\n   */\n  from: number;\n\n  /**\n   * The destination row index to move to.\n   */\n  to: number;\n\n  /**\n   * Whether to select the moved row after the operation.\n   *\n   * @default true\n   */\n  select?: boolean;\n\n  /**\n   * Optional position to resolve table from. If not provided, uses the current selection.\n   */\n  pos?: number;\n}\n\n/**\n * Move a table row from index `from` to index `to`.\n *\n * @public\n */\nexport function moveTableRow(options: MoveTableRowOptions): Command {\n  return (state, dispatch) => {\n    const {\n      from: originIndex,\n      to: targetIndex,\n      select = true,\n      pos = state.selection.from,\n    } = options;\n    const tr = state.tr;\n    if (moveRow({ tr, originIndex, targetIndex, select, pos })) {\n      dispatch?.(tr);\n      return true;\n    }\n    return false;\n  };\n}\n\n/**\n * Options for moveTableColumn\n *\n * @public\n */\nexport interface MoveTableColumnOptions {\n  /**\n   * The source column index to move from.\n   */\n  from: number;\n\n  /**\n   * The destination column index to move to.\n   */\n  to: number;\n\n  /**\n   * Whether to select the moved column after the operation.\n   *\n   * @default true\n   */\n  select?: boolean;\n\n  /**\n   * Optional position to resolve table from. If not provided, uses the current selection.\n   */\n  pos?: number;\n}\n\n/**\n * Move a table column from index `from` to index `to`.\n *\n * @public\n */\nexport function moveTableColumn(options: MoveTableColumnOptions): Command {\n  return (state, dispatch) => {\n    const {\n      from: originIndex,\n      to: targetIndex,\n      select = true,\n      pos = state.selection.from,\n    } = options;\n    const tr = state.tr;\n    if (moveColumn({ tr, originIndex, targetIndex, select, pos })) {\n      dispatch?.(tr);\n      return true;\n    }\n    return false;\n  };\n}\n", "// Utilities used for copy/paste handling.\n//\n// This module handles pasting cell content into tables, or pasting\n// anything into a cell selection, as replacing a block of cells with\n// the content of the selection. When pasting cells into a cell, that\n// involves placing the block of pasted content so that its top left\n// aligns with the selection cell, optionally extending the table to\n// the right or bottom to make sure it is large enough. Pasting into a\n// cell selection is different, here the cells in the selection are\n// clipped to the selection's rectangle, optionally repeating the\n// pasted cells when they are smaller than the selection.\n\nimport type { Node, NodeType, Schema } from 'prosemirror-model';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport type { EditorState, Transaction } from 'prosemirror-state';\nimport { Transform } from 'prosemirror-transform';\n\nimport { CellSelection } from './cellselection';\nimport { tableNodeTypes } from './schema';\nimport type { ColWidths, Rect } from './tablemap';\nimport { TableMap } from './tablemap';\nimport type { CellAttrs } from './util';\nimport { removeColSpan } from './util';\n\n/**\n * @internal\n */\nexport type Area = { width: number; height: number; rows: Fragment[] };\n\n// Utilities to help with copying and pasting table cells\n\n/**\n * Get a rectangular area of cells from a slice, or null if the outer\n * nodes of the slice aren't table cells or rows.\n *\n * @internal\n */\nexport function pastedCells(slice: Slice): Area | null {\n  if (slice.size === 0) return null;\n  let { content, openStart, openEnd } = slice;\n  while (\n    content.childCount == 1 &&\n    ((openStart > 0 && openEnd > 0) ||\n      content.child(0).type.spec.tableRole == 'table')\n  ) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema,\n    rows = [];\n  if (role == 'row') {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice(cells, left, right),\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == 'cell' || role == 'header_cell') {\n    rows.push(\n      openStart || openEnd\n        ? fitSlice(\n            tableNodeTypes(schema).row,\n            new Slice(content, openStart, openEnd),\n          ).content\n        : content,\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\n\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\nfunction ensureRectangular(schema: Schema, rows: Fragment[]): Area {\n  const widths: ColWidths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill()!;\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\n\nexport function fitSlice(nodeType: NodeType, slice: Slice): Node {\n  const node = nodeType.createAndFill()!;\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\n\n/**\n * Clip or extend (repeat) the given set of cells to cover the given\n * width and height. Will clip rowspan/colspan cells at the edges when\n * they stick out.\n *\n * @internal\n */\nexport function clipCells(\n  { width, height, rows }: Area,\n  newWidth: number,\n  newHeight: number,\n): Area {\n  if (width != newWidth) {\n    const added: number[] = [];\n    const newRows: Fragment[] = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row],\n        cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs as CellAttrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth,\n            ),\n            cell.content,\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [],\n        source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan),\n            },\n            cell.content,\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n\n  return { width, height, rows };\n}\n\n// Make sure a table has at least the given width and height. Return\n// true if something was changed.\nfunction growTable(\n  tr: Transaction,\n  map: TableMap,\n  table: Node,\n  start: number,\n  width: number,\n  height: number,\n  mapFrom: number,\n): boolean {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells: Node[] = [];\n      let add: Node;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill()!);\n      else add = emptyHead || (emptyHead = types.header_cell.createAndFill()!);\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (\n      let i = 0, start = (map.height - 1) * map.width;\n      i < Math.max(map.width, width);\n      i++\n    ) {\n      const header =\n        i >= map.width\n          ? false\n          : table.nodeAt(map.map[start + i])!.type == types.header_cell;\n      cells.push(\n        header\n          ? emptyHead || (emptyHead = types.header_cell.createAndFill()!)\n          : empty || (empty = types.cell.createAndFill()!),\n      );\n    }\n\n    const emptyRow = types.row.create(null, Fragment.from(cells)),\n      rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\n\n// Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\nfunction isolateHorizontal(\n  tr: Transaction,\n  map: TableMap,\n  table: Node,\n  start: number,\n  left: number,\n  right: number,\n  top: number,\n  mapFrom: number,\n): boolean {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col,\n      pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos)!;\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop,\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top,\n        })!,\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\n\n// Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\nfunction isolateVertical(\n  tr: Transaction,\n  map: TableMap,\n  table: Node,\n  start: number,\n  top: number,\n  bottom: number,\n  left: number,\n  mapFrom: number,\n): boolean {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left,\n      pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos)!;\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs as CellAttrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft),\n        ),\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs as CellAttrs, 0, left - cellLeft),\n        )!,\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\n\n/**\n * Insert the given set of cells (as returned by `pastedCells`) into a\n * table, at the position pointed at by rect.\n *\n * @internal\n */\nexport function insertCells(\n  state: EditorState,\n  dispatch: (tr: Transaction) => void,\n  tableStart: number,\n  rect: Rect,\n  cells: Area,\n): void {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error('No table found');\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width,\n    bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n\n  function recomp(): void {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error('No table found');\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n\n  // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (\n    isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)\n  )\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table),\n      to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice(cells.rows[row - top], 0, 0),\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table)),\n    ),\n  );\n  dispatch(tr);\n}\n", "// This file defines a number of helpers for wiring up user input to\n// table-related functionality.\n\nimport { keydownHandler } from 'prosemirror-keymap';\nimport type { ResolvedPos, Slice } from 'prosemirror-model';\nimport { Fragment } from 'prosemirror-model';\nimport type { Command, EditorState, Transaction } from 'prosemirror-state';\nimport { Selection, TextSelection } from 'prosemirror-state';\nimport type { EditorView } from 'prosemirror-view';\n\nimport { CellSelection } from './cellselection';\nimport { deleteCellSelection } from './commands';\nimport { clipCells, fitSlice, insertCells, pastedCells } from './copypaste';\nimport { tableNodeTypes } from './schema';\nimport { TableMap } from './tablemap';\nimport {\n  cellAround,\n  inSameTable,\n  isInTable,\n  nextCell,\n  selectionCell,\n  tableEditingKey,\n} from './util';\n\ntype Axis = 'horiz' | 'vert';\n\n/**\n * @public\n */\nexport type Direction = -1 | 1;\n\nexport const handleKeyDown = keydownHandler({\n  ArrowLeft: arrow('horiz', -1),\n  ArrowRight: arrow('horiz', 1),\n  ArrowUp: arrow('vert', -1),\n  ArrowDown: arrow('vert', 1),\n\n  'Shift-ArrowLeft': shiftArrow('horiz', -1),\n  'Shift-ArrowRight': shiftArrow('horiz', 1),\n  'Shift-ArrowUp': shiftArrow('vert', -1),\n  'Shift-ArrowDown': shiftArrow('vert', 1),\n\n  Backspace: deleteCellSelection,\n  'Mod-Backspace': deleteCellSelection,\n  Delete: deleteCellSelection,\n  'Mod-Delete': deleteCellSelection,\n});\n\nfunction maybeSetSelection(\n  state: EditorState,\n  dispatch: undefined | ((tr: Transaction) => void),\n  selection: Selection,\n): boolean {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\n\n/**\n * @internal\n */\nexport function arrow(axis: Axis, dir: Direction): Command {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection.near(sel.$headCell, dir),\n      );\n    }\n    if (axis != 'horiz' && !sel.empty) return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == 'horiz') {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection.near(state.doc.resolve(sel.head + dir), dir),\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next) newSel = Selection.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);\n      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\n\nfunction shiftArrow(axis: Axis, dir: Direction): Command {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    let cellSel: CellSelection;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head),\n    );\n  };\n}\n\nexport function handleTripleClick(view: EditorView, pos: number): boolean {\n  const doc = view.state.doc,\n    $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\n\n/**\n * @public\n */\nexport function handlePaste(\n  view: EditorView,\n  _: ClipboardEvent,\n  slice: Slice,\n): boolean {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice),\n          ),\n        ],\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start,\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells,\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function handleMouseDown(\n  view: EditorView,\n  startEvent: MouseEvent,\n): void {\n  // Only handle mouse down events for the main button (usually the left button).\n  // This ensures that the cell selection won't be triggered when trying to open\n  // the context menu.\n  if (startEvent.button != 0) return;\n\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n\n  const startDOMCell = domInCell(view, startEvent.target as Node);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (\n    startEvent.shiftKey &&\n    startDOMCell &&\n    ($anchor = cellAround(view.state.selection.$anchor)) != null &&\n    cellUnderMouse(view, startEvent)?.pos != $anchor.pos\n  ) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return;\n  }\n\n  // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n  function setCellSelection($anchor: ResolvedPos, event: MouseEvent): void {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) $head = $anchor;\n      else return;\n    }\n    const selection = new CellSelection($anchor, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(tableEditingKey, $anchor.pos);\n      view.dispatch(tr);\n    }\n  }\n\n  // Stop listening to mouse motion events.\n  function stop(): void {\n    view.root.removeEventListener('mouseup', stop);\n    view.root.removeEventListener('dragstart', stop);\n    view.root.removeEventListener('mousemove', move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n\n  function move(_event: Event): void {\n    const event = _event as MouseEvent;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor;\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target as Node) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent);\n      if (!$anchor) return stop();\n    }\n    if ($anchor) setCellSelection($anchor, event);\n  }\n\n  view.root.addEventListener('mouseup', stop);\n  view.root.addEventListener('dragstart', stop);\n  view.root.addEventListener('mousemove', move);\n}\n\n// Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\nfunction atEndOfCell(view: EditorView, axis: Axis, dir: number): null | number {\n  if (!(view.state.selection instanceof TextSelection)) return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d),\n      index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (\n      parent.type.spec.tableRole == 'cell' ||\n      parent.type.spec.tableRole == 'header_cell'\n    ) {\n      const cellPos = $head.before(d);\n      const dirStr: 'up' | 'down' | 'left' | 'right' =\n        axis == 'vert' ? (dir > 0 ? 'down' : 'up') : dir > 0 ? 'right' : 'left';\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\n\nfunction domInCell(view: EditorView, dom: Node | null): Node | null {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == 'TD' || dom.nodeName == 'TH') {\n      return dom;\n    }\n  }\n  return null;\n}\n\nfunction cellUnderMouse(\n  view: EditorView,\n  event: MouseEvent,\n): ResolvedPos | null {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY,\n  });\n  if (!mousePos) return null;\n  // Prefer `inside` position for better accuracy with merged cells (rowspan/colspan),\n  // but fall back to `pos` if `inside` doesn't resolve to a valid cell\n  let { inside, pos } = mousePos;\n  return (\n    (inside >= 0 && cellAround(view.state.doc.resolve(inside))) ||\n    cellAround(view.state.doc.resolve(pos))\n  );\n}\n", "import type { Node } from 'prosemirror-model';\nimport type { NodeView, ViewMutationRecord } from 'prosemirror-view';\n\nimport type { CellAttrs } from './util';\n\n/**\n * @public\n */\nexport class TableView implements NodeView {\n  public dom: HTMLDivElement;\n  public table: HTMLTableElement;\n  public colgroup: HTMLTableColElement;\n  public contentDOM: HTMLTableSectionElement;\n\n  constructor(\n    public node: Node,\n    public defaultCellMinWidth: number,\n  ) {\n    this.dom = document.createElement('div');\n    this.dom.className = 'tableWrapper';\n    this.table = this.dom.appendChild(document.createElement('table'));\n    this.table.style.setProperty(\n      '--default-cell-min-width',\n      `${defaultCellMinWidth}px`,\n    );\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n  }\n\n  update(node: Node): boolean {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumnsOnResize(\n      node,\n      this.colgroup,\n      this.table,\n      this.defaultCellMinWidth,\n    );\n    return true;\n  }\n\n  ignoreMutation(record: ViewMutationRecord): boolean {\n    return (\n      record.type == 'attributes' &&\n      (record.target == this.table || this.colgroup.contains(record.target))\n    );\n  }\n}\n\n/**\n * @public\n */\nexport function updateColumnsOnResize(\n  node: Node,\n  colgroup: HTMLTableColElement,\n  table: HTMLTableElement,\n  defaultCellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: number,\n): void {\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild as HTMLElement;\n  const row = node.firstChild;\n  if (!row) return;\n\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs as CellAttrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth =\n        overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + 'px' : '';\n      totalWidth += hasWidth || defaultCellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        const col = document.createElement('col');\n        col.style.width = cssWidth;\n        colgroup.appendChild(col);\n      } else {\n        if (nextDOM.style.width != cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n        nextDOM = nextDOM.nextSibling as HTMLElement;\n      }\n    }\n  }\n\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    nextDOM.parentNode?.removeChild(nextDOM);\n    nextDOM = after as HTMLElement;\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + 'px';\n    table.style.minWidth = '';\n  } else {\n    table.style.width = '';\n    table.style.minWidth = totalWidth + 'px';\n  }\n}\n", "import type { Attrs, Node as ProsemirrorNode } from 'prosemirror-model';\nimport type { EditorState, Transaction } from 'prosemirror-state';\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport type { EditorView, NodeView } from 'prosemirror-view';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\n\nimport { tableNodeTypes } from './schema';\nimport { TableMap } from './tablemap';\nimport { TableView, updateColumnsOnResize } from './tableview';\nimport type { CellAttrs } from './util';\nimport { cellAround, pointsAtCell } from './util';\n\n/**\n * @public\n */\nexport const columnResizingPluginKey = new PluginKey<ResizeState>(\n  'tableColumnResizing',\n);\n\n/**\n * @public\n */\nexport type ColumnResizingOptions = {\n  handleWidth?: number;\n  /**\n   * Minimum width of a cell /column. The column cannot be resized smaller than this.\n   */\n  cellMinWidth?: number;\n  /**\n   * The default minWidth of a cell / column when it doesn't have an explicit width (i.e.: it has not been resized manually)\n   */\n  defaultCellMinWidth?: number;\n  lastColumnResizable?: boolean;\n  /**\n   * A custom node view for the rendering table nodes. By default, the plugin\n   * uses the {@link TableView} class. You can explicitly set this to `null` to\n   * not use a custom node view.\n   */\n  View?:\n    | (new (\n        node: ProsemirrorNode,\n        cellMinWidth: number,\n        view: EditorView,\n      ) => NodeView)\n    | null;\n};\n\n/**\n * @public\n */\nexport type Dragging = { startX: number; startWidth: number };\n\n/**\n * @public\n */\nexport function columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  defaultCellMinWidth = 100,\n  View = TableView,\n  lastColumnResizable = true,\n}: ColumnResizingOptions = {}): Plugin {\n  const plugin = new Plugin<ResizeState>({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        const nodeViews = plugin.spec?.props?.nodeViews;\n        const tableName = tableNodeTypes(state.schema).table.name;\n        if (View && nodeViews) {\n          nodeViews[tableName] = (node, view) => {\n            return new View(node, defaultCellMinWidth, view);\n          };\n        }\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      },\n    },\n    props: {\n      attributes: (state): Record<string, string> => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1\n          ? { class: 'resize-cursor' }\n          : {};\n      },\n\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(view, event, handleWidth, lastColumnResizable);\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown(view, event, cellMinWidth, defaultCellMinWidth);\n        },\n      },\n\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n\n      nodeViews: {},\n    },\n  });\n  return plugin;\n}\n\n/**\n * @public\n */\nexport class ResizeState {\n  constructor(\n    public activeHandle: number,\n    public dragging: Dragging | false,\n  ) {}\n\n  apply(tr: Transaction): ResizeState {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== undefined)\n      return new ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n}\n\nfunction handleMouseMove(\n  view: EditorView,\n  event: MouseEvent,\n  handleWidth: number,\n  lastColumnResizable: boolean,\n): void {\n  if (!view.editable) return;\n\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState) return;\n\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target as HTMLElement);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, 'left', handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, 'right', handleWidth);\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col =\n          map.colCount($cell.pos - tableStart) +\n          $cell.nodeAfter!.attrs.colspan -\n          1;\n\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n\n      updateHandle(view, cell);\n    }\n  }\n}\n\nfunction handleMouseLeave(view: EditorView): void {\n  if (!view.editable) return;\n\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\n\nfunction handleMouseDown(\n  view: EditorView,\n  event: MouseEvent,\n  cellMinWidth: number,\n  defaultCellMinWidth: number,\n): boolean {\n  if (!view.editable) return false;\n\n  const win = view.dom.ownerDocument.defaultView ?? window;\n\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle)!;\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width },\n    }),\n  );\n\n  function finish(event: MouseEvent) {\n    win.removeEventListener('mouseup', finish);\n    win.removeEventListener('mousemove', move);\n    const pluginState = columnResizingPluginKey.getState(view.state);\n    if (pluginState?.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState.activeHandle,\n        draggedWidth(pluginState.dragging, event, cellMinWidth),\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null }),\n      );\n    }\n  }\n\n  function move(event: MouseEvent): void {\n    if (!event.which) return finish(event);\n    const pluginState = columnResizingPluginKey.getState(view.state);\n    if (!pluginState) return;\n    if (pluginState.dragging) {\n      const dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);\n      displayColumnWidth(\n        view,\n        pluginState.activeHandle,\n        dragged,\n        defaultCellMinWidth,\n      );\n    }\n  }\n\n  displayColumnWidth(\n    view,\n    pluginState.activeHandle,\n    width,\n    defaultCellMinWidth,\n  );\n\n  win.addEventListener('mouseup', finish);\n  win.addEventListener('mousemove', move);\n  event.preventDefault();\n  return true;\n}\n\nfunction currentColWidth(\n  view: EditorView,\n  cellPos: number,\n  { colspan, colwidth }: Attrs,\n): number {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset] as HTMLElement;\n  let domWidth = node.offsetWidth,\n    parts = colspan;\n  if (colwidth)\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  return domWidth / parts;\n}\n\nfunction domCellAround(target: HTMLElement | null): HTMLElement | null {\n  while (target && target.nodeName != 'TD' && target.nodeName != 'TH')\n    target =\n      target.classList && target.classList.contains('ProseMirror')\n        ? null\n        : (target.parentNode as HTMLElement);\n  return target;\n}\n\nfunction edgeCell(\n  view: EditorView,\n  event: MouseEvent,\n  side: 'left' | 'right',\n  handleWidth: number,\n): number {\n  // posAtCoords returns inconsistent positions when cursor is moving\n  // across a collapsed table border. Use an offset to adjust the\n  // target viewport coordinates away from the table border.\n  const offset = side == 'right' ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY,\n  });\n  if (!found) return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == 'right') return $cell.pos;\n  const map = TableMap.get($cell.node(-1)),\n    start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\n\nfunction draggedWidth(\n  dragging: Dragging,\n  event: MouseEvent,\n  resizeMinWidth: number,\n): number {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(resizeMinWidth, dragging.startWidth + offset);\n}\n\nfunction updateHandle(view: EditorView, value: number): void {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value }),\n  );\n}\n\nfunction updateColumnWidth(\n  view: EditorView,\n  cell: number,\n  width: number,\n): void {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1),\n    map = TableMap.get(table),\n    start = $cell.start(-1);\n  const col =\n    map.colCount($cell.pos - start) + $cell.nodeAfter!.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    // Rowspanning cell that has already been handled\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos)!.attrs as CellAttrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    const colwidth = attrs.colwidth\n      ? attrs.colwidth.slice()\n      : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth: colwidth });\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\n\nfunction displayColumnWidth(\n  view: EditorView,\n  cell: number,\n  width: number,\n  defaultCellMinWidth: number,\n): void {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1),\n    start = $cell.start(-1);\n  const col =\n    TableMap.get(table).colCount($cell.pos - start) +\n    $cell.nodeAfter!.attrs.colspan -\n    1;\n  let dom: Node | null = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != 'TABLE') {\n    dom = dom.parentNode;\n  }\n  if (!dom) return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild as HTMLTableColElement,\n    dom as HTMLTableElement,\n    defaultCellMinWidth,\n    col,\n    width,\n  );\n}\n\nfunction zeroes(n: number): 0[] {\n  return Array(n).fill(0);\n}\n\nexport function handleDecorations(\n  state: EditorState,\n  cell: number,\n): DecorationSet {\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col =\n    map.colCount($cell.pos - start) + $cell.nodeAfter!.attrs.colspan - 1;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width;\n    // For positions that have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n    if (\n      (col == map.width - 1 || map.map[index] != map.map[index + 1]) &&\n      (row == 0 || map.map[index] != map.map[index - map.width])\n    ) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos)!.nodeSize - 1;\n      const dom = document.createElement('div');\n      dom.className = 'column-resize-handle';\n      if (columnResizingPluginKey.getState(state)?.dragging) {\n        decorations.push(\n          Decoration.node(\n            start + cellPos,\n            start + cellPos + table.nodeAt(cellPos)!.nodeSize,\n            {\n              class: 'column-resize-dragging',\n            },\n          ),\n        );\n      }\n\n      decorations.push(Decoration.widget(pos, dom));\n    }\n  }\n  return DecorationSet.create(state.doc, decorations);\n}\n", "// This file defines a plugin that handles the drawing of cell\n// selections and the basic user interactions for creating and working\n// with such selections. It also makes sure that, after each\n// transaction, the shapes of tables are normalized to be rectangular\n// and not contain overlapping cells.\n\nimport { Plugin } from 'prosemirror-state';\n\nimport { drawCellSelection, normalizeSelection } from './cellselection';\nimport { fixTables, fixTablesKey } from './fixtables';\nimport {\n  handleKeyDown,\n  handleMouseDown,\n  handlePaste,\n  handleTripleClick,\n} from './input';\nimport { tableEditingKey } from './util';\n\nexport { CellBookmark, CellSelection } from './cellselection';\nexport type { CellSelectionJSON } from './cellselection';\nexport {\n  columnResizing,\n  columnResizingPluginKey,\n  ResizeState,\n} from './columnresizing';\nexport type { ColumnResizingOptions, Dragging } from './columnresizing';\nexport * from './commands';\nexport {\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n} from './copypaste';\nexport type { Area as __Area } from './copypaste';\nexport type { Direction } from './input';\nexport { tableNodes, tableNodeTypes } from './schema';\nexport type {\n  CellAttributes,\n  getFromDOM,\n  setDOMAttr,\n  TableNodes,\n  TableNodesOptions,\n  TableRole,\n} from './schema';\nexport { TableMap } from './tablemap';\nexport type { ColWidths, Problem, Rect } from './tablemap';\nexport { TableView, updateColumnsOnResize } from './tableview';\nexport {\n  addColSpan,\n  cellAround,\n  cellNear,\n  colCount,\n  columnIsHeader,\n  findCell,\n  inSameTable,\n  isInTable,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  selectionCell,\n} from './util';\nexport type { MutableAttrs } from './util';\nexport { findCellPos, findCellRange, findTable } from './utils/query';\nexport type { FindNodeResult } from './utils/query';\nexport { fixTables, fixTablesKey, handlePaste, tableEditingKey };\n\n/**\n * @public\n */\nexport type TableEditingOptions = {\n  /**\n   * Whether to allow table node selection.\n   *\n   * By default, any node selection wrapping a table will be converted into a\n   * CellSelection wrapping all cells in the table. You can pass `true` to allow\n   * the selection to remain a NodeSelection.\n   *\n   * @default false\n   */\n  allowTableNodeSelection?: boolean;\n};\n\n/**\n * Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n * that, when added to an editor, enables cell-selection, handles\n * cell-based copy/paste, and makes sure tables stay well-formed (each\n * row has the same width, and cells don't overlap).\n *\n * You should probably put this plugin near the end of your array of\n * plugins, since it handles mouse and arrow key events in tables\n * rather broadly, and other plugins, like the gap cursor or the\n * column-width dragging plugin, might want to get a turn first to\n * perform more specific behavior.\n *\n * @public\n */\nexport function tableEditing({\n  allowTableNodeSelection = false,\n}: TableEditingOptions = {}): Plugin {\n  return new Plugin({\n    key: tableEditingKey,\n\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      },\n    },\n\n    props: {\n      decorations: drawCellSelection,\n\n      handleDOMEvents: {\n        mousedown: handleMouseDown,\n      },\n\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null\n          ? view.state.selection\n          : null;\n      },\n\n      handleTripleClick,\n\n      handleKeyDown,\n\n      handlePaste,\n    },\n\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection,\n      );\n    },\n  });\n}\n", "import { Extension } from '@tiptap/core'\n\nimport type { BubbleMenuPluginProps } from './bubble-menu-plugin.js'\nimport { BubbleMenuPlugin } from './bubble-menu-plugin.js'\n\nexport type BubbleMenuOptions = Omit<BubbleMenuPluginProps, 'editor' | 'element'> & {\n  /**\n   * The DOM element that contains your menu.\n   * @type {HTMLElement}\n   * @default null\n   */\n  element: HTMLElement | null\n}\n\n/**\n * This extension allows you to create a bubble menu.\n * @see https://tiptap.dev/api/extensions/bubble-menu\n */\nexport const BubbleMenu = Extension.create<BubbleMenuOptions>({\n  name: 'bubbleMenu',\n\n  addOptions() {\n    return {\n      element: null,\n      pluginKey: 'bubbleMenu',\n      updateDelay: undefined,\n      appendTo: undefined,\n      shouldShow: null,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return []\n    }\n\n    return [\n      BubbleMenuPlugin({\n        pluginKey: this.options.pluginKey,\n        editor: this.editor,\n        element: this.options.element,\n        updateDelay: this.options.updateDelay,\n        options: this.options.options,\n        appendTo: this.options.appendTo,\n        getReferencedVirtualElement: this.options.getReferencedVirtualElement,\n        shouldShow: this.options.shouldShow,\n      }),\n    ]\n  },\n})\n", "import {\n  type Middleware,\n  type VirtualElement,\n  arrow,\n  autoPlacement,\n  computePosition,\n  flip,\n  hide,\n  inline,\n  offset,\n  shift,\n  size,\n} from '@floating-ui/dom'\nimport type { Editor } from '@tiptap/core'\nimport { isTextSelection, posToDOMRect } from '@tiptap/core'\nimport type { EditorState, PluginView, Transaction } from '@tiptap/pm/state'\nimport { NodeSelection, Plugin, PluginKey } from '@tiptap/pm/state'\nimport { CellSelection } from '@tiptap/pm/tables'\nimport type { EditorView } from '@tiptap/pm/view'\n\nfunction combineDOMRects(rect1: DOMRect, rect2: DOMRect): DOMRect {\n  const top = Math.min(rect1.top, rect2.top)\n  const bottom = Math.max(rect1.bottom, rect2.bottom)\n  const left = Math.min(rect1.left, rect2.left)\n  const right = Math.max(rect1.right, rect2.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  return new DOMRect(x, y, width, height)\n}\n\nexport interface BubbleMenuPluginProps {\n  /**\n   * The plugin key.\n   * @type {PluginKey | string}\n   * @default 'bubbleMenu'\n   */\n  pluginKey: PluginKey | string\n\n  /**\n   * The editor instance.\n   */\n  editor: Editor\n\n  /**\n   * The DOM element that contains your menu.\n   * @type {HTMLElement}\n   * @default null\n   */\n  element: HTMLElement\n\n  /**\n   * The delay in milliseconds before the menu should be updated.\n   * This can be useful to prevent performance issues.\n   * @type {number}\n   * @default 250\n   */\n  updateDelay?: number\n\n  /**\n   * The delay in milliseconds before the menu position should be updated on window resize.\n   * This can be useful to prevent performance issues.\n   * @type {number}\n   * @default 60\n   */\n  resizeDelay?: number\n\n  /**\n   * A function that determines whether the menu should be shown or not.\n   * If this function returns `false`, the menu will be hidden, otherwise it will be shown.\n   */\n  shouldShow?:\n    | ((props: {\n        editor: Editor\n        element: HTMLElement\n        view: EditorView\n        state: EditorState\n        oldState?: EditorState\n        from: number\n        to: number\n      }) => boolean)\n    | null\n\n  /**\n   * The DOM element to append your menu to. Default is the editor's parent element.\n   *\n   * Sometimes the menu needs to be appended to a different DOM context due to accessibility, clipping, or z-index issues.\n   *\n   * @type {HTMLElement}\n   * @default null\n   */\n  appendTo?: HTMLElement | (() => HTMLElement)\n\n  /**\n   * A function that returns the virtual element for the menu.\n   * This is useful when the menu needs to be positioned relative to a specific DOM element.\n   * @type {() => VirtualElement | null}\n   * @default Position based on the selection.\n   */\n  getReferencedVirtualElement?: () => VirtualElement | null\n\n  /**\n   * The options for the bubble menu. Those are passed to Floating UI and include options for the placement, offset, flip, shift, arrow, size, autoPlacement,\n   * hide, and inline middlewares.\n   * @default {}\n   * @see https://floating-ui.com/docs/computePosition#options\n   */\n  options?: {\n    strategy?: 'absolute' | 'fixed'\n    placement?:\n      | 'top'\n      | 'right'\n      | 'bottom'\n      | 'left'\n      | 'top-start'\n      | 'top-end'\n      | 'right-start'\n      | 'right-end'\n      | 'bottom-start'\n      | 'bottom-end'\n      | 'left-start'\n      | 'left-end'\n    offset?: Parameters<typeof offset>[0] | boolean\n    flip?: Parameters<typeof flip>[0] | boolean\n    shift?: Parameters<typeof shift>[0] | boolean\n    arrow?: Parameters<typeof arrow>[0] | false\n    size?: Parameters<typeof size>[0] | boolean\n    autoPlacement?: Parameters<typeof autoPlacement>[0] | boolean\n    hide?: Parameters<typeof hide>[0] | boolean\n    inline?: Parameters<typeof inline>[0] | boolean\n\n    onShow?: () => void\n    onHide?: () => void\n    onUpdate?: () => void\n    onDestroy?: () => void\n\n    /**\n     * The scrollable element that should be listened to when updating the position of the bubble menu.\n     * If not provided, the window will be used.\n     * @type {HTMLElement | Window}\n     */\n    scrollTarget?: HTMLElement | Window\n  }\n}\n\nexport type BubbleMenuViewProps = BubbleMenuPluginProps & {\n  view: EditorView\n}\n\nexport class BubbleMenuView implements PluginView {\n  public editor: Editor\n\n  public element: HTMLElement\n\n  public view: EditorView\n\n  public preventHide = false\n\n  public updateDelay: number\n\n  public resizeDelay: number\n\n  public appendTo: HTMLElement | (() => HTMLElement) | undefined\n\n  public getReferencedVirtualElement: (() => VirtualElement | null) | undefined\n\n  private updateDebounceTimer: number | undefined\n\n  private resizeDebounceTimer: number | undefined\n\n  private isVisible = false\n\n  private scrollTarget: HTMLElement | Window = window\n\n  private floatingUIOptions: NonNullable<BubbleMenuPluginProps['options']> = {\n    strategy: 'absolute',\n    placement: 'top',\n    offset: 8,\n    flip: {},\n    shift: {},\n    arrow: false,\n    size: false,\n    autoPlacement: false,\n    hide: false,\n    inline: false,\n    onShow: undefined,\n    onHide: undefined,\n    onUpdate: undefined,\n    onDestroy: undefined,\n  }\n\n  public shouldShow: Exclude<BubbleMenuPluginProps['shouldShow'], null> = ({ view, state, from, to }) => {\n    const { doc, selection } = state\n    const { empty } = selection\n\n    // Sometime check for `empty` is not enough.\n    // Doubleclick an empty paragraph returns a node size of 2.\n    // So we check also for an empty text size.\n    const isEmptyTextBlock = !doc.textBetween(from, to).length && isTextSelection(state.selection)\n\n    // When clicking on a element inside the bubble menu the editor \"blur\" event\n    // is called and the bubble menu item is focussed. In this case we should\n    // consider the menu as part of the editor and keep showing the menu\n    const isChildOfMenu = this.element.contains(document.activeElement)\n\n    const hasEditorFocus = view.hasFocus() || isChildOfMenu\n\n    if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n      return false\n    }\n\n    return true\n  }\n\n  get middlewares() {\n    const middlewares: Middleware[] = []\n\n    if (this.floatingUIOptions.flip) {\n      middlewares.push(flip(typeof this.floatingUIOptions.flip !== 'boolean' ? this.floatingUIOptions.flip : undefined))\n    }\n\n    if (this.floatingUIOptions.shift) {\n      middlewares.push(\n        shift(typeof this.floatingUIOptions.shift !== 'boolean' ? this.floatingUIOptions.shift : undefined),\n      )\n    }\n\n    if (this.floatingUIOptions.offset) {\n      middlewares.push(\n        offset(typeof this.floatingUIOptions.offset !== 'boolean' ? this.floatingUIOptions.offset : undefined),\n      )\n    }\n\n    if (this.floatingUIOptions.arrow) {\n      middlewares.push(arrow(this.floatingUIOptions.arrow))\n    }\n\n    if (this.floatingUIOptions.size) {\n      middlewares.push(size(typeof this.floatingUIOptions.size !== 'boolean' ? this.floatingUIOptions.size : undefined))\n    }\n\n    if (this.floatingUIOptions.autoPlacement) {\n      middlewares.push(\n        autoPlacement(\n          typeof this.floatingUIOptions.autoPlacement !== 'boolean' ? this.floatingUIOptions.autoPlacement : undefined,\n        ),\n      )\n    }\n\n    if (this.floatingUIOptions.hide) {\n      middlewares.push(hide(typeof this.floatingUIOptions.hide !== 'boolean' ? this.floatingUIOptions.hide : undefined))\n    }\n\n    if (this.floatingUIOptions.inline) {\n      middlewares.push(\n        inline(typeof this.floatingUIOptions.inline !== 'boolean' ? this.floatingUIOptions.inline : undefined),\n      )\n    }\n\n    return middlewares\n  }\n\n  private get virtualElement(): VirtualElement | undefined {\n    const { selection } = this.editor.state\n\n    const referencedVirtualElement = this.getReferencedVirtualElement?.()\n    if (referencedVirtualElement) {\n      return referencedVirtualElement\n    }\n\n    if (!this.view?.dom?.parentNode) {\n      return\n    }\n\n    const domRect = posToDOMRect(this.view, selection.from, selection.to)\n    let virtualElement = {\n      getBoundingClientRect: () => domRect,\n      getClientRects: () => [domRect],\n    }\n\n    if (selection instanceof NodeSelection) {\n      let node = this.view.nodeDOM(selection.from) as HTMLElement\n\n      const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector('[data-node-view-wrapper]')\n\n      if (nodeViewWrapper) {\n        node = nodeViewWrapper as HTMLElement\n      }\n\n      if (node) {\n        virtualElement = {\n          getBoundingClientRect: () => node.getBoundingClientRect(),\n          getClientRects: () => [node.getBoundingClientRect()],\n        }\n      }\n    }\n\n    // this is a special case for cell selections\n    if (selection instanceof CellSelection) {\n      const { $anchorCell, $headCell } = selection\n\n      const from = $anchorCell ? $anchorCell.pos : $headCell!.pos\n      const to = $headCell ? $headCell.pos : $anchorCell!.pos\n\n      const fromDOM = this.view.nodeDOM(from)\n      const toDOM = this.view.nodeDOM(to)\n\n      if (!fromDOM || !toDOM) {\n        return\n      }\n\n      const clientRect =\n        fromDOM === toDOM\n          ? (fromDOM as HTMLElement).getBoundingClientRect()\n          : combineDOMRects(\n              (fromDOM as HTMLElement).getBoundingClientRect(),\n              (toDOM as HTMLElement).getBoundingClientRect(),\n            )\n\n      virtualElement = {\n        getBoundingClientRect: () => clientRect,\n        getClientRects: () => [clientRect],\n      }\n    }\n\n    return virtualElement\n  }\n\n  constructor({\n    editor,\n    element,\n    view,\n    updateDelay = 250,\n    resizeDelay = 60,\n    shouldShow,\n    appendTo,\n    getReferencedVirtualElement,\n    options,\n  }: BubbleMenuViewProps) {\n    this.editor = editor\n    this.element = element\n    this.view = view\n    this.updateDelay = updateDelay\n    this.resizeDelay = resizeDelay\n    this.appendTo = appendTo\n    this.scrollTarget = options?.scrollTarget ?? window\n    this.getReferencedVirtualElement = getReferencedVirtualElement\n\n    this.floatingUIOptions = {\n      ...this.floatingUIOptions,\n      ...options,\n    }\n\n    this.element.tabIndex = 0\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow\n    }\n\n    this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.addEventListener('dragstart', this.dragstartHandler)\n    this.editor.on('focus', this.focusHandler)\n    this.editor.on('blur', this.blurHandler)\n    this.editor.on('transaction', this.transactionHandler)\n    window.addEventListener('resize', this.resizeHandler)\n    this.scrollTarget.addEventListener('scroll', this.resizeHandler)\n\n    this.update(view, view.state)\n\n    if (this.getShouldShow()) {\n      this.show()\n      this.updatePosition()\n    }\n  }\n\n  mousedownHandler = () => {\n    this.preventHide = true\n  }\n\n  dragstartHandler = () => {\n    this.hide()\n  }\n\n  /**\n   * Handles the window resize event to update the position of the bubble menu.\n   * It uses a debounce mechanism to prevent excessive updates.\n   * The delay is defined by the `resizeDelay` property.\n   */\n  resizeHandler = () => {\n    if (this.resizeDebounceTimer) {\n      clearTimeout(this.resizeDebounceTimer)\n    }\n\n    this.resizeDebounceTimer = window.setTimeout(() => {\n      this.updatePosition()\n    }, this.resizeDelay)\n  }\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.editor.view))\n  }\n\n  blurHandler = ({ event }: { event: FocusEvent }) => {\n    if (this.editor.isDestroyed) {\n      this.destroy()\n      return\n    }\n\n    if (this.preventHide) {\n      this.preventHide = false\n\n      return\n    }\n\n    if (event?.relatedTarget && this.element.parentNode?.contains(event.relatedTarget as Node)) {\n      return\n    }\n\n    if (event?.relatedTarget === this.editor.view.dom) {\n      return\n    }\n\n    this.hide()\n  }\n\n  updatePosition() {\n    const virtualElement = this.virtualElement\n\n    if (!virtualElement) {\n      return\n    }\n\n    computePosition(virtualElement, this.element, {\n      placement: this.floatingUIOptions.placement,\n      strategy: this.floatingUIOptions.strategy,\n      middleware: this.middlewares,\n    }).then(({ x, y, strategy, middlewareData }) => {\n      // Handle hide middleware - hide element if reference is hidden or element has escaped\n      if (middlewareData.hide?.referenceHidden || middlewareData.hide?.escaped) {\n        this.element.style.visibility = 'hidden'\n        return\n      }\n\n      this.element.style.visibility = 'visible'\n      this.element.style.width = 'max-content'\n      this.element.style.position = strategy\n      this.element.style.left = `${x}px`\n      this.element.style.top = `${y}px`\n\n      if (this.isVisible && this.floatingUIOptions.onUpdate) {\n        this.floatingUIOptions.onUpdate()\n      }\n    })\n  }\n\n  update(view: EditorView, oldState?: EditorState) {\n    const { state } = view\n    const hasValidSelection = state.selection.from !== state.selection.to\n\n    if (this.updateDelay > 0 && hasValidSelection) {\n      this.handleDebouncedUpdate(view, oldState)\n      return\n    }\n\n    const selectionChanged = !oldState?.selection.eq(view.state.selection)\n    const docChanged = !oldState?.doc.eq(view.state.doc)\n\n    this.updateHandler(view, selectionChanged, docChanged, oldState)\n  }\n\n  handleDebouncedUpdate = (view: EditorView, oldState?: EditorState) => {\n    const selectionChanged = !oldState?.selection.eq(view.state.selection)\n    const docChanged = !oldState?.doc.eq(view.state.doc)\n\n    if (!selectionChanged && !docChanged) {\n      return\n    }\n\n    if (this.updateDebounceTimer) {\n      clearTimeout(this.updateDebounceTimer)\n    }\n\n    this.updateDebounceTimer = window.setTimeout(() => {\n      this.updateHandler(view, selectionChanged, docChanged, oldState)\n    }, this.updateDelay)\n  }\n\n  getShouldShow(oldState?: EditorState) {\n    const { state } = this.view\n    const { selection } = state\n\n    // support for CellSelections\n    const { ranges } = selection\n    const from = Math.min(...ranges.map(range => range.$from.pos))\n    const to = Math.max(...ranges.map(range => range.$to.pos))\n\n    const shouldShow = this.shouldShow?.({\n      editor: this.editor,\n      element: this.element,\n      view: this.view,\n      state,\n      oldState,\n      from,\n      to,\n    })\n\n    return shouldShow || false\n  }\n\n  updateHandler = (view: EditorView, selectionChanged: boolean, docChanged: boolean, oldState?: EditorState) => {\n    const { composing } = view\n\n    const isSame = !selectionChanged && !docChanged\n\n    if (composing || isSame) {\n      return\n    }\n\n    const shouldShow = this.getShouldShow(oldState)\n\n    if (!shouldShow) {\n      this.hide()\n\n      return\n    }\n\n    this.updatePosition()\n    this.show()\n  }\n\n  show() {\n    if (this.isVisible) {\n      return\n    }\n\n    this.element.style.visibility = 'visible'\n    this.element.style.opacity = '1'\n\n    // attach to appendTo or editor's parent element\n    const appendToElement = typeof this.appendTo === 'function' ? this.appendTo() : this.appendTo\n    ;(appendToElement ?? this.view.dom.parentElement)?.appendChild(this.element)\n\n    if (this.floatingUIOptions.onShow) {\n      this.floatingUIOptions.onShow()\n    }\n\n    this.isVisible = true\n  }\n\n  hide() {\n    if (!this.isVisible) {\n      return\n    }\n\n    this.element.style.visibility = 'hidden'\n    this.element.style.opacity = '0'\n    // remove from the parent element\n    this.element.remove()\n\n    if (this.floatingUIOptions.onHide) {\n      this.floatingUIOptions.onHide()\n    }\n\n    this.isVisible = false\n  }\n\n  transactionHandler = ({ transaction: tr }: { transaction: Transaction }) => {\n    const meta = tr.getMeta('bubbleMenu')\n    if (meta === 'updatePosition') {\n      this.updatePosition()\n    } else if (meta && typeof meta === 'object' && meta.type === 'updateOptions') {\n      this.updateOptions(meta.options)\n    }\n  }\n\n  updateOptions(newProps: Partial<Omit<BubbleMenuPluginProps, 'editor' | 'element' | 'pluginKey'>>) {\n    if (newProps.updateDelay !== undefined) {\n      this.updateDelay = newProps.updateDelay\n    }\n\n    if (newProps.resizeDelay !== undefined) {\n      this.resizeDelay = newProps.resizeDelay\n    }\n\n    if (newProps.appendTo !== undefined) {\n      this.appendTo = newProps.appendTo\n    }\n\n    if (newProps.getReferencedVirtualElement !== undefined) {\n      this.getReferencedVirtualElement = newProps.getReferencedVirtualElement\n    }\n\n    if (newProps.shouldShow !== undefined) {\n      if (newProps.shouldShow) {\n        this.shouldShow = newProps.shouldShow\n      }\n    }\n\n    if (newProps.options !== undefined) {\n      // Handle scrollTarget change - need to remove old listener and add new one\n      // Use nullish coalescing to default to window when scrollTarget is undefined/null\n      const newScrollTarget = newProps.options.scrollTarget ?? window\n\n      if (newScrollTarget !== this.scrollTarget) {\n        this.scrollTarget.removeEventListener('scroll', this.resizeHandler)\n        this.scrollTarget = newScrollTarget\n        this.scrollTarget.addEventListener('scroll', this.resizeHandler)\n      }\n\n      this.floatingUIOptions = {\n        ...this.floatingUIOptions,\n        ...newProps.options,\n      }\n    }\n  }\n\n  destroy() {\n    this.hide()\n    this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.removeEventListener('dragstart', this.dragstartHandler)\n    window.removeEventListener('resize', this.resizeHandler)\n    this.scrollTarget.removeEventListener('scroll', this.resizeHandler)\n    this.editor.off('focus', this.focusHandler)\n    this.editor.off('blur', this.blurHandler)\n    this.editor.off('transaction', this.transactionHandler)\n\n    if (this.floatingUIOptions.onDestroy) {\n      this.floatingUIOptions.onDestroy()\n    }\n  }\n}\n\nexport const BubbleMenuPlugin = (options: BubbleMenuPluginProps) => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n    view: view => new BubbleMenuView({ view, ...options }),\n  })\n}\n", "import { BubbleMenu } from './bubble-menu.js'\n\nexport * from './bubble-menu.js'\nexport * from './bubble-menu-plugin.js'\n\nexport default BubbleMenu\n", "import { Extension } from '@tiptap/core'\n\nimport type { FloatingMenuPluginProps } from './floating-menu-plugin.js'\nimport { FloatingMenuPlugin } from './floating-menu-plugin.js'\n\nexport type FloatingMenuOptions = Omit<FloatingMenuPluginProps, 'editor' | 'element'> & {\n  /**\n   * The DOM element that contains your menu.\n   * @type {HTMLElement}\n   * @default null\n   */\n  element: HTMLElement | null\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    floatingMenu: {\n      /**\n       * Update the position of the floating menu.\n       * @example editor.commands.updateFloatingMenuPosition()\n       */\n      updateFloatingMenuPosition: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create a floating menu.\n * @see https://tiptap.dev/api/extensions/floating-menu\n */\nexport const FloatingMenu = Extension.create<FloatingMenuOptions>({\n  name: 'floatingMenu',\n\n  addOptions() {\n    return {\n      element: null,\n      options: {},\n      pluginKey: 'floatingMenu',\n      updateDelay: undefined,\n      resizeDelay: undefined,\n      appendTo: undefined,\n      shouldShow: null,\n    }\n  },\n\n  addCommands() {\n    return {\n      updateFloatingMenuPosition:\n        () =>\n        ({ tr, dispatch }) => {\n          if (dispatch) {\n            tr.setMeta('floatingMenu', 'updatePosition')\n          }\n          return true\n        },\n    }\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return []\n    }\n\n    return [\n      FloatingMenuPlugin({\n        pluginKey: this.options.pluginKey,\n        editor: this.editor,\n        element: this.options.element,\n        updateDelay: this.options.updateDelay,\n        resizeDelay: this.options.resizeDelay,\n        options: this.options.options,\n        appendTo: this.options.appendTo,\n        shouldShow: this.options.shouldShow,\n      }),\n    ]\n  },\n})\n", "import {\n  type Middleware,\n  arrow,\n  autoPlacement,\n  computePosition,\n  flip,\n  hide,\n  inline,\n  offset,\n  shift,\n  size,\n} from '@floating-ui/dom'\nimport type { Editor } from '@tiptap/core'\nimport { getText, getTextSerializersFromSchema, posToDOMRect } from '@tiptap/core'\nimport type { Node as ProsemirrorNode } from '@tiptap/pm/model'\nimport type { EditorState, Transaction } from '@tiptap/pm/state'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport type { EditorView } from '@tiptap/pm/view'\n\nexport interface FloatingMenuPluginProps {\n  /**\n   * The plugin key for the floating menu.\n   * @default 'floatingMenu'\n   */\n  pluginKey: PluginKey | string\n\n  /**\n   * The editor instance.\n   * @default null\n   */\n  editor: Editor\n\n  /**\n   * The DOM element that contains your menu.\n   * @default null\n   */\n  element: HTMLElement\n\n  /**\n   * The delay in milliseconds before the menu should be updated.\n   * This can be useful to prevent performance issues.\n   * @type {number}\n   * @default 250\n   */\n  updateDelay?: number\n\n  /**\n   * The delay in milliseconds before the menu position should be updated on window resize.\n   * This can be useful to prevent performance issues.\n   * @type {number}\n   * @default 60\n   */\n  resizeDelay?: number\n\n  /**\n   * The DOM element to append your menu to. Default is the editor's parent element.\n   *\n   * Sometimes the menu needs to be appended to a different DOM context due to accessibility, clipping, or z-index issues.\n   *\n   * @type {HTMLElement}\n   * @default null\n   */\n  appendTo?: HTMLElement | (() => HTMLElement)\n\n  /**\n   * A function that determines whether the menu should be shown or not.\n   * If this function returns `false`, the menu will be hidden, otherwise it will be shown.\n   */\n  shouldShow?:\n    | ((props: {\n        editor: Editor\n        view: EditorView\n        state: EditorState\n        oldState?: EditorState\n        from: number\n        to: number\n      }) => boolean)\n    | null\n\n  /**\n   * The options for the floating menu. Those are passed to Floating UI and include options for the placement, offset, flip, shift, arrow, size, autoPlacement,\n   * hide, and inline middlewares.\n   * @default {}\n   * @see https://floating-ui.com/docs/computePosition#options\n   */\n  options?: {\n    strategy?: 'absolute' | 'fixed'\n    placement?:\n      | 'top'\n      | 'right'\n      | 'bottom'\n      | 'left'\n      | 'top-start'\n      | 'top-end'\n      | 'right-start'\n      | 'right-end'\n      | 'bottom-start'\n      | 'bottom-end'\n      | 'left-start'\n      | 'left-end'\n    offset?: Parameters<typeof offset>[0] | boolean\n    flip?: Parameters<typeof flip>[0] | boolean\n    shift?: Parameters<typeof shift>[0] | boolean\n    arrow?: Parameters<typeof arrow>[0] | false\n    size?: Parameters<typeof size>[0] | boolean\n    autoPlacement?: Parameters<typeof autoPlacement>[0] | boolean\n    hide?: Parameters<typeof hide>[0] | boolean\n    inline?: Parameters<typeof inline>[0] | boolean\n\n    onShow?: () => void\n    onHide?: () => void\n    onUpdate?: () => void\n    onDestroy?: () => void\n\n    /**\n     * The scrollable element that should be listened to when updating the position of the floating menu.\n     * If not provided, the window will be used.\n     * @type {HTMLElement | Window}\n     */\n    scrollTarget?: HTMLElement | Window\n  }\n}\n\nexport type FloatingMenuViewProps = FloatingMenuPluginProps & {\n  /**\n   * The editor view.\n   */\n  view: EditorView\n}\n\nexport class FloatingMenuView {\n  public editor: Editor\n\n  public element: HTMLElement\n\n  public view: EditorView\n\n  public preventHide = false\n\n  /**\n   * The delay in milliseconds before the menu should be updated.\n   * @default 250\n   */\n  public updateDelay: number\n\n  /**\n   * The delay in milliseconds before the menu position should be updated on window resize.\n   * @default 60\n   */\n  public resizeDelay: number\n\n  public appendTo: HTMLElement | (() => HTMLElement) | undefined\n\n  private updateDebounceTimer: number | undefined\n\n  private resizeDebounceTimer: number | undefined\n\n  private isVisible = false\n\n  private scrollTarget: HTMLElement | Window = window\n\n  private getTextContent(node: ProsemirrorNode) {\n    return getText(node, { textSerializers: getTextSerializersFromSchema(this.editor.schema) })\n  }\n\n  public shouldShow: Exclude<FloatingMenuPluginProps['shouldShow'], null> = ({ view, state }) => {\n    const { selection } = state\n    const { $anchor, empty } = selection\n    const isRootDepth = $anchor.depth === 1\n\n    const isEmptyTextBlock =\n      $anchor.parent.isTextblock &&\n      !$anchor.parent.type.spec.code &&\n      !$anchor.parent.textContent &&\n      $anchor.parent.childCount === 0 &&\n      !this.getTextContent($anchor.parent)\n\n    if (!view.hasFocus() || !empty || !isRootDepth || !isEmptyTextBlock || !this.editor.isEditable) {\n      return false\n    }\n\n    return true\n  }\n\n  private floatingUIOptions: NonNullable<FloatingMenuPluginProps['options']> = {\n    strategy: 'absolute',\n    placement: 'right',\n    offset: 8,\n    flip: {},\n    shift: {},\n    arrow: false,\n    size: false,\n    autoPlacement: false,\n    hide: false,\n    inline: false,\n  }\n\n  get middlewares() {\n    const middlewares: Middleware[] = []\n\n    if (this.floatingUIOptions.flip) {\n      middlewares.push(flip(typeof this.floatingUIOptions.flip !== 'boolean' ? this.floatingUIOptions.flip : undefined))\n    }\n\n    if (this.floatingUIOptions.shift) {\n      middlewares.push(\n        shift(typeof this.floatingUIOptions.shift !== 'boolean' ? this.floatingUIOptions.shift : undefined),\n      )\n    }\n\n    if (this.floatingUIOptions.offset) {\n      middlewares.push(\n        offset(typeof this.floatingUIOptions.offset !== 'boolean' ? this.floatingUIOptions.offset : undefined),\n      )\n    }\n\n    if (this.floatingUIOptions.arrow) {\n      middlewares.push(arrow(this.floatingUIOptions.arrow))\n    }\n\n    if (this.floatingUIOptions.size) {\n      middlewares.push(size(typeof this.floatingUIOptions.size !== 'boolean' ? this.floatingUIOptions.size : undefined))\n    }\n\n    if (this.floatingUIOptions.autoPlacement) {\n      middlewares.push(\n        autoPlacement(\n          typeof this.floatingUIOptions.autoPlacement !== 'boolean' ? this.floatingUIOptions.autoPlacement : undefined,\n        ),\n      )\n    }\n\n    if (this.floatingUIOptions.hide) {\n      middlewares.push(hide(typeof this.floatingUIOptions.hide !== 'boolean' ? this.floatingUIOptions.hide : undefined))\n    }\n\n    if (this.floatingUIOptions.inline) {\n      middlewares.push(\n        inline(typeof this.floatingUIOptions.inline !== 'boolean' ? this.floatingUIOptions.inline : undefined),\n      )\n    }\n\n    return middlewares\n  }\n\n  constructor({\n    editor,\n    element,\n    view,\n    updateDelay = 250,\n    resizeDelay = 60,\n    options,\n    appendTo,\n    shouldShow,\n  }: FloatingMenuViewProps) {\n    this.editor = editor\n    this.element = element\n    this.view = view\n    this.updateDelay = updateDelay\n    this.resizeDelay = resizeDelay\n    this.appendTo = appendTo\n    this.scrollTarget = options?.scrollTarget ?? window\n\n    this.floatingUIOptions = {\n      ...this.floatingUIOptions,\n      ...options,\n    }\n\n    this.element.tabIndex = 0\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow\n    }\n\n    this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.editor.on('focus', this.focusHandler)\n    this.editor.on('blur', this.blurHandler)\n    this.editor.on('transaction', this.transactionHandler)\n    window.addEventListener('resize', this.resizeHandler)\n    this.scrollTarget.addEventListener('scroll', this.resizeHandler)\n\n    this.update(view, view.state)\n\n    if (this.getShouldShow()) {\n      this.show()\n      this.updatePosition()\n    }\n  }\n\n  getShouldShow(oldState?: EditorState) {\n    const { state } = this.view\n    const { selection } = state\n\n    const { ranges } = selection\n    const from = Math.min(...ranges.map(range => range.$from.pos))\n    const to = Math.max(...ranges.map(range => range.$to.pos))\n\n    const shouldShow = this.shouldShow?.({\n      editor: this.editor,\n      view: this.view,\n      state,\n      oldState,\n      from,\n      to,\n    })\n\n    return shouldShow\n  }\n\n  updateHandler = (view: EditorView, selectionChanged: boolean, docChanged: boolean, oldState?: EditorState) => {\n    const { composing } = view\n\n    const isSame = !selectionChanged && !docChanged\n\n    if (composing || isSame) {\n      return\n    }\n\n    const shouldShow = this.getShouldShow(oldState)\n\n    if (!shouldShow) {\n      this.hide()\n\n      return\n    }\n\n    this.updatePosition()\n    this.show()\n  }\n\n  mousedownHandler = () => {\n    this.preventHide = true\n  }\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.editor.view))\n  }\n\n  blurHandler = ({ event }: { event: FocusEvent }) => {\n    if (this.preventHide) {\n      this.preventHide = false\n\n      return\n    }\n\n    if (event?.relatedTarget && this.element.parentNode?.contains(event.relatedTarget as Node)) {\n      return\n    }\n\n    if (event?.relatedTarget === this.editor.view.dom) {\n      return\n    }\n\n    this.hide()\n  }\n\n  /**\n   * Handles the transaction event to update the position of the floating menu.\n   * This allows external code to trigger a position update via:\n   * `editor.view.dispatch(editor.state.tr.setMeta('floatingMenu', 'updatePosition'))`\n   */\n  transactionHandler = ({ transaction: tr }: { transaction: Transaction }) => {\n    const meta = tr.getMeta('floatingMenu')\n    if (meta === 'updatePosition') {\n      this.updatePosition()\n    } else if (meta && typeof meta === 'object' && meta.type === 'updateOptions') {\n      this.updateOptions(meta.options)\n    }\n  }\n\n  updateOptions(newProps: Partial<Omit<FloatingMenuPluginProps, 'editor' | 'element' | 'pluginKey'>>) {\n    if (newProps.updateDelay !== undefined) {\n      this.updateDelay = newProps.updateDelay\n    }\n\n    if (newProps.resizeDelay !== undefined) {\n      this.resizeDelay = newProps.resizeDelay\n    }\n\n    if (newProps.appendTo !== undefined) {\n      this.appendTo = newProps.appendTo\n    }\n\n    if (newProps.shouldShow !== undefined) {\n      if (newProps.shouldShow) {\n        this.shouldShow = newProps.shouldShow\n      }\n    }\n\n    if (newProps.options !== undefined) {\n      // Handle scrollTarget change - need to remove old listener and add new one\n      // Use nullish coalescing to default to window when scrollTarget is undefined/null\n      const newScrollTarget = newProps.options.scrollTarget ?? window\n\n      if (newScrollTarget !== this.scrollTarget) {\n        this.scrollTarget.removeEventListener('scroll', this.resizeHandler)\n        this.scrollTarget = newScrollTarget\n        this.scrollTarget.addEventListener('scroll', this.resizeHandler)\n      }\n\n      this.floatingUIOptions = {\n        ...this.floatingUIOptions,\n        ...newProps.options,\n      }\n    }\n  }\n\n  /**\n   * Handles the window resize event to update the position of the floating menu.\n   * It uses a debounce mechanism to prevent excessive updates.\n   * The delay is defined by the `resizeDelay` property.\n   */\n  resizeHandler = () => {\n    if (this.resizeDebounceTimer) {\n      clearTimeout(this.resizeDebounceTimer)\n    }\n\n    this.resizeDebounceTimer = window.setTimeout(() => {\n      this.updatePosition()\n    }, this.resizeDelay)\n  }\n\n  updatePosition() {\n    const { selection } = this.editor.state\n\n    const domRect = posToDOMRect(this.view, selection.from, selection.to)\n\n    const virtualElement = {\n      getBoundingClientRect: () => domRect,\n      getClientRects: () => [domRect],\n    }\n\n    computePosition(virtualElement, this.element, {\n      placement: this.floatingUIOptions.placement,\n      strategy: this.floatingUIOptions.strategy,\n      middleware: this.middlewares,\n    }).then(({ x, y, strategy, middlewareData }) => {\n      // Handle hide middleware - hide element if reference is hidden or element has escaped\n      if (middlewareData.hide?.referenceHidden || middlewareData.hide?.escaped) {\n        this.element.style.visibility = 'hidden'\n        return\n      }\n\n      this.element.style.visibility = 'visible'\n      this.element.style.width = 'max-content'\n      this.element.style.position = strategy\n      this.element.style.left = `${x}px`\n      this.element.style.top = `${y}px`\n\n      if (this.isVisible && this.floatingUIOptions.onUpdate) {\n        this.floatingUIOptions.onUpdate()\n      }\n    })\n  }\n\n  update(view: EditorView, oldState?: EditorState) {\n    const selectionChanged = !oldState?.selection.eq(view.state.selection)\n    const docChanged = !oldState?.doc.eq(view.state.doc)\n\n    this.updateHandler(view, selectionChanged, docChanged, oldState)\n  }\n\n  show() {\n    if (this.isVisible) {\n      return\n    }\n\n    this.element.style.visibility = 'visible'\n    this.element.style.opacity = '1'\n\n    // attach to appendTo or editor's parent element\n    const appendToElement = typeof this.appendTo === 'function' ? this.appendTo() : this.appendTo\n    ;(appendToElement ?? this.view.dom.parentElement)?.appendChild(this.element)\n\n    if (this.floatingUIOptions.onShow) {\n      this.floatingUIOptions.onShow()\n    }\n\n    this.isVisible = true\n  }\n\n  hide() {\n    if (!this.isVisible) {\n      return\n    }\n\n    this.element.style.visibility = 'hidden'\n    this.element.style.opacity = '0'\n    // remove from the parent element\n    this.element.remove()\n\n    if (this.floatingUIOptions.onHide) {\n      this.floatingUIOptions.onHide()\n    }\n\n    this.isVisible = false\n  }\n\n  destroy() {\n    this.hide()\n    this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true })\n    window.removeEventListener('resize', this.resizeHandler)\n    this.scrollTarget.removeEventListener('scroll', this.resizeHandler)\n    this.editor.off('focus', this.focusHandler)\n    this.editor.off('blur', this.blurHandler)\n    this.editor.off('transaction', this.transactionHandler)\n\n    if (this.floatingUIOptions.onDestroy) {\n      this.floatingUIOptions.onDestroy()\n    }\n  }\n}\n\nexport const FloatingMenuPlugin = (options: FloatingMenuPluginProps) => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n    view: view => new FloatingMenuView({ view, ...options }),\n  })\n}\n", "import { FloatingMenu } from './floating-menu.js'\n\nexport * from './floating-menu.js'\nexport * from './floating-menu-plugin.js'\n\nexport default FloatingMenu\n"],
  "mappings": "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",
  "names": ["import_react", "import_react", "import_shim", "size", "areArrayBuffersEqual", "areArraysEqual", "areDataViewsEqual", "areDatesEqual", "areErrorsEqual", "areFunctionsEqual", "areMapsEqual", "areNumbersEqual", "areObjectsEqual", "arePrimitiveWrappersEqual", "areRegExpsEqual", "areSetsEqual", "areTypedArraysEqual", "areUrlsEqual", "areObjectsEqualStrictDefault", "areArraysEqualDefault", "areMapsEqualDefault", "areObjectsEqualDefault", "areSetsEqualDefault", "areTypedArraysEqualDefault", "import_react", "import_jsx_runtime", "import_react", "import_react_dom", "import_jsx_runtime", "import_react", "import_jsx_runtime", "platform", "max", "offset", "alignment", "placements", "sides", "side", "placement", "overflow", "getBoundingClientRect", "top", "bottom", "left", "right", "width", "height", "x", "y", "min", "platform", "getComputedStyle", "getComputedStyle", "offset", "autoPlacement", "shift", "flip", "size", "hide", "arrow", "inline", "computePosition", "readFromCache: (key: Node) => TableMap | undefined", "addToCache: (key: Node, value: TableMap) => TableMap", "cache: (Node | TableMap)[]", "width: number", "height: number", "map: number[]", "problems: Problem[] | null", "result: number[]", "seen: Record<number, boolean>", "colWidths: ColWidths", "h", "result: ColWidths", "result: CellAttrs", "CellSelection", "seen: Record<number, boolean>", "CellBookmark", "anchor: number", "head: number", "toggleHeaderRow: Command", "toggleHeaderColumn: Command", "toggleHeaderCell: Command", "arrow", "cellSel: CellSelection", "dirStr: 'up' | 'down' | 'left' | 'right'", "view", "_a", "shouldShow", "flip", "shift", "offset", "arrow", "size", "autoPlacement", "hide", "inline", "computePosition", "import_react", "import_react_dom", "import_jsx_runtime", "view", "shouldShow", "_a", "flip", "shift", "offset", "arrow", "size", "autoPlacement", "hide", "inline", "computePosition", "import_react", "import_react_dom", "import_jsx_runtime", "ReactDOM", "React", "useState", "useSyncExternalStore", "useDebugValue", "useEffect", "jsxs", "jsx", "createContext", "useContext", "reactVersion", "componentProps", "createElement", "BubbleMenu", "useRef", "useCurrentEditor", "FloatingMenu", "createPortal", "useMemo"]
}
